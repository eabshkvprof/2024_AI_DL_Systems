# Лекція 6.7. Можливості перевантаження операторів. Визначення понять об’єктів ітерування, ітератора та генератора

# Перевантаження операторів
Перевантаження операторів у Python - це можливість за допомогою спеціальних методів у класах перевизначати різні оператори мови. Імена таких методів включають подвійне підкреслення спереду і ззаду.

Під операторами в даному контексті розуміються не тільки знаки +, -, *, /, що забезпечують операції додавання, віднімання тощо, а й також специфіка синтаксису мови, що забезпечує операції створення об'єкта, виклику об'єкта як функції, звернення до елемента об'єкта за індексом, виведення об'єкта та інше.
Ми вже використовували низку вбудованих методів. Це

```__init__()``` - конструктор об'єктів класу, викликається при створенні об'єктів


```python
class A:
  def __init__(self, value=0):
    self.field=value

a = A()

b = A(3)
```

```__del__()``` - деструктор об'єктів класу, викликається під час видалення об'єктів

```__str__()``` - перетворення об'єкта до рядкового подання, викликається, коли об'єкт передається функціям print() і str()

```__add__()``` - метод перевантаження оператора додавання, викликається, коли об'єкт бере участь в операції додавання будучи операндом з лівого боку


```python
class Stars:
  def __init__(self, n):
    self.qty= "*" * n

  def __add__(self, n):
    return self.qty + '*' * n

  def __str__(self):
    return "Qty " + self.qty

a = Stars(3)

b = a + 5

print("A:",a)
print("B:",b)
```

    A: Qty ***
    B: ********
    

```__setattr__()``` - викликається, коли атрибуту об'єкта виконується присвоювання


```python
class A:
  def __init__(self, v):
    self.field = v

  def __setattr__(self, attr, value):
    if attr == 'field':
      self.__dict__[attr] = value
    else:
      raise AttributeError

a = A(15)

a.field = -3
```

У Python багато інших методів перевантаження операторів.

Насправді перевантаження операторів у користувацьких класах використовується не так часто, якщо не брати до уваги конструктора. Але сам факт наявності такої особливості об'єктно-орієнтованого програмування вимагає окремого розгляду теми.

Але для короткого прикладу розглянемо деякі з цих методів на прикладі двовимірного вектора, для якого перевизначимо деякі методи:


```python
import math

class Vector2D:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return 'Vector2D({}, {})'.format(self.x, self.y)

    def __str__(self):
        return '({}, {})'.format(self.x, self.y)

    def __add__(self, other):
        return Vector2D(self.x + other.x, self.y + other.y)

    def __iadd__(self, other):
        self.x += other.x
        self.y += other.y
        return self

    def __sub__(self, other):
        return Vector2D(self.x - other.x, self.y - other.y)

    def __isub__(self, other):
        self.x -= other.x
        self.y -= other.y
        return self

    def __abs__(self):
        return math.hypot(self.x, self.y)

    def __bool__(self):
        return self.x != 0 or self.y != 0

    def __neg__(self):
        return Vector2D(-self.x, -self.y)
```


```python
x = Vector2D(3, 4) # Створення об'єкту x
print(x) # __str__ (3, 4)
print(abs(x)) #__abs__ 5.0
y = Vector2D(5, 6) # Створення об'єкту y
print(x + y) # __add__ (8, 10)
print(x - y) # __sub__ (-2, -2)
print(-x) # __neg__ (-3, -4)
x += y # __iadd__, якщо немає імплементації, викликає __add__
print(x) # (8, 10)
print(bool(x)) # __bool__ True
z = Vector2D(0, 0) # Створення об'єкту z
print(bool(z)) # __bool__ False
print(-z) # __neg__ (0,0)
```

    (3, 4)
    5.0
    (8, 10)
    (-2, -2)
    (-3, -4)
    (8, 10)
    True
    False
    (0, 0)
    

# Ітератори та генератори

Генератори та ітератори являють собою інструменти, які, як правило, використовуються для потокової обробки даних.

У багатьох сучасних мовах програмування використовують такі сутності як ітератори. Основне їхнє призначення - це спрощення навігації по елементах об'єкта, який, як правило, являє собою деяку колекцію (список, словник тощо). Мова Python, у цьому випадку, не виняток і в ній теж є підтримка ітераторів. Ітератор являє собою об'єкт перечислювач, який для даного об'єкта видає наступний елемент, або кидає виняток, якщо елементів більше немає.

Основне місце використання ітераторів - це цикл for. Якщо ви перебираєте елементи в деякому списку або символи в рядку за допомогою циклу for, то, фактично, це означає, що під час кожної ітерації циклу відбувається звернення до ітератора, який міститься в рядку/списку, з вимогою видати наступний елемент, якщо елементів в об'єкті більше немає, то ітератор генерує виняток, що обробляється в рамках циклу for непомітно для користувача.

Наведемо кілька прикладів, які допоможуть краще зрозуміти цю концепцію. Для початку виведемо елементи довільного списку на екран.


```python
num_list = [1, 2, 3, 4, 5]
for i in num_list:
  print(i, end=" ")
```

    1 2 3 4 5 

Як уже було сказано, об'єкти, елементи яких можна перебирати в циклі for, містять у собі об'єкт ітератор, для того, щоб його отримати, необхідно використати функцію iter(), а для вилучення наступного елемента з ітератора - функцію next().


```python
itr = iter(num_list)
print(next(itr))
print(next(itr))
print(next(itr))
print(next(itr))
print(next(itr))
# print(next(itr))
```

    1
    2
    3
    4
    5
    

Як видно з наведеного вище прикладу, виклик функції next(itr) щоразу повертає наступний елемент зі списку, а коли ці елементи закінчуються, генерується виняток StopIteration.

## Створення власних ітераторів
Якщо потрібно обійти елементи всередині об'єкта вашого власного класу, необхідно побудувати свій ітератор. Створимо клас, об'єкт якого буде ітератором, що видає певну кількість одиниць, яку користувач задає під час створення об'єкта. Такий клас буде містити конструктор, що приймає на вхід кількість одиниць і метод __next__(), без нього екземпляри цього класу не будуть ітераторами.


```python
class SimpleIterator:
    def __init__(self, limit):
        self.limit = limit
        self.counter = 0

    def __next__(self):
        if self.counter < self.limit:
            self.counter += 1
            return 1
        else:
          raise StopIteration

s_iter1 = SimpleIterator(3)
print(next(s_iter1))
print(next(s_iter1))
print(next(s_iter1))
# print(next(s_iter1))
```

У нашому прикладі під час четвертого виклику функції next() буде викинуто виняток StopIteration. Якщо ми хочемо, щоб з даним об'єктом можна було працювати в циклі for, то в клас SimpleIterator потрібно додати метод __iter__(), який повертає ітератор, в даному випадку цей метод повинен повертати self.


```python
class SimpleIterator:
    def __iter__(self):
        return self

    def __init__(self, limit):
        self.limit = limit
        self.counter = 0

    def __next__(self):
        if self.counter < self.limit:
            self.counter += 1
            return 1
        else:
            raise StopIteration

s_iter2 = SimpleIterator(5)
for i in s_iter2:
    print(i, end=" ")
```

    1 1 1 1 1 

# Генератори
Генератори дозволяють значно спростити роботу з конструювання ітераторів. У попередніх прикладах, для побудови ітератора і роботи з ним, ми створювали окремий клас. Генератор - це функція, яка будучи викликаною у функції next() повертає наступний об'єкт згідно з алгоритмом її роботи. Замість ключового слова return у генераторі використовується yield. Найпростіше роботу генератора подивитися на прикладі. Напишемо функцію, яка генерує необхідну нам кількість одиниць.


```python
def simple_generator(val):
   while val > 0:
       val -= 1
       yield 1

gen_iter = simple_generator(5)
print(next(gen_iter))
print(next(gen_iter))
print(next(gen_iter))
print(next(gen_iter))
print(next(gen_iter))
#print(next(gen_iter))
```

    1
    1
    1
    1
    1
    

Ця функція працюватиме так само, як клас SimpleIterator із попереднього прикладу.

Ключовим моментом для розуміння роботи генераторів є те, що під час виклику yield функція не припиняє свою роботу, а "заморожується" до чергової ітерації, що запускається функцією next(). Якщо ви у своєму генераторі, десь використовуєте ключове слово return, то дійшовши до цього місця, буде викинуто виняток StopIteration, а якщо після ключового слова return помістити будь-яку інформацію, то вона буде додана до опису StopIteration.
