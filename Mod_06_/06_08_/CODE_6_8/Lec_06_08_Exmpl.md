# Лекція 6.8. Убудовані функції та вбудовані класи виняткових ситуацій

# Оброблення помилок і винятків
## Конструкція try...except...finally

Під час програмування Python ми можемо зіткнутися з двома типами помилок. Перший тип становлять синтаксичні помилки (syntax error). Вони з'являються внаслідок порушення синтаксису мови програмування під час написання вихідного коду. За наявності таких помилок програма не може бути скомпільована. Під час роботи в будь-якому середовищі розроблення, наприклад, у PyCharm, IDE сама може відстежувати синтаксичні помилки і якимось чином їх виділяти.

Другий тип помилок представляють помилки виконання (runtime error). Вони з'являються у вже скомпільованій програмі в процесі її виконання. Подібні помилки ще називаються винятками. Наприклад, у минулих лекціях ми розглядали перетворення рядка в число:


```python
string = "1"
number = int(string)
print(number)
print(type(number))
```

    1
    <class 'int'>
    

Цей скрипт успішно скомпілюється і виконається, оскільки рядок "1" цілком може бути конвертований у число. Однак візьмемо інший приклад:


```python
string = "привіт"
number = int(string)
print(number)
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-3-3cc4d9ef3889> in <cell line: 2>()
          1 string = "привіт"
    ----> 2 number = int(string)
          3 print(number)
    

    ValueError: invalid literal for int() with base 10: 'привіт'


Під час виконання цього скрипта буде викинуто виняток ValueError, оскільки рядок "hello" не можна перетворити на число:
```
ValueError: invalid literal for int() with base 10: 'hello'
```
З одного боку, тут очевидно, що рядок не представляє число, але ми можемо мати справу з введенням користувача, який також може ввести не зовсім те, що ми очікуємо:


```python
string = input("Введіть число: ")
number = int(string)
print(number)
```

    Введіть число: dfgdfgdfg
    


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-5-87b4f0e71508> in <cell line: 2>()
          1 string = input("Введіть число: ")
    ----> 2 number = int(string)
          3 print(number)
    

    ValueError: invalid literal for int() with base 10: 'dfgdfgdfg'


При виникненні винятку робота програми переривається, і щоб уникнути подібної поведінки та обробляти винятки, в Python є конструкція try..except.

## try..except

Конструкція try..except має таке формальне визначення:
```
try:
    інструкції
except [Тип_винятку]:
    інструкції
```

Увесь основний код, у якому потенційно може виникнути виняток, поміщається після ключового слова try. Якщо в цьому коді генерується виняток, то робота коду в блоці try переривається, і виконання переходить у блок except.

Після ключового слова except опціонально можна вказати, яке виняток буде оброблятися (наприклад, ValueError або KeyError). Після слова except на наступному рядку йдуть інструкції блоку except, що виконуються у разі виникнення винятку.

Розглянемо обробку винятку на прикладі перетворення рядка в число:


```python
try:
    number = int(input("Введіть число: "))
    print("Введене число:", number)
except:
    print("Error! You need to enter a number, not a string")

print("Завершення програми")
```

    Введіть число: a
    Перетворення пройшло невдало
    Завершення програми
    

## Блок finally

Під час обробки винятків також можна використовувати необов'язковий блок finally. Відмінною особливістю цього блоку є те, що він виконується незалежно від того, чи було згенеровано виняток:



```python
try:
    number = int(input("Введіть число: "))
    print("Введене число:", number)
except:
    print("Перетворення пройшло невдало")
finally:
    print("Блок try завершив виконання")
print("Завершення програми")
```

    Введіть число: 12
    Введене число: 12
    Блок try завершив виконання
    Завершення програми
    

Як правило, блок finally застосовується для звільнення використовуваних ресурсів, наприклад, для закриття файлів.

## Except і обробка різних типів винятків
## Вбудовані типи винятків

У прикладі вище оброблялися відразу всі винятки, які можуть виникнути в коді. Однак ми можемо конкретизувати тип оброблюваного виключення, вказавши його після слова except:



```python
try:
    number = int(input("Введіть число: "))
    print("Введене число:", number)
except ValueError:
    print("Перетворення пройшло невдало")
print("Завершення програми")
```

    Введіть число: sdsdg
    Перетворення пройшло невдало
    Завершення програми
    

У цьому випадку блок execpt обробляє тільки винятки типу ValueError, які можуть виникнути в разі невдалого перетворення рядка в число.

У Python є такі базові типи винятків:
1. BaseException: базовий тип для всіх вбудованих винятків

2. Exception: базовий тип, який зазвичай застосовується для створення своїх типів винятків

3. ArithmeticError: базовий тип для винятків, пов'язаних з арифметичними операціями (OverflowError, ZeroDivisionError, FloatingPointError).

4. BufferError: тип винятку, що виникає при неможливості виконати операцію з буфером

5. LookupError: базовий тип для винятків, що виникають при зверненні в колекціях за некоректним ключем або індексом (наприклад, IndexError, KeyError)

Від цих класів успадковуються всі конкретні типи винятків. Python має досить великий список вбудованих винятків. Весь цей список можна подивитися в документації. Перерахуємо ті, що зустрічаються найчастіше:
1. IndexError: виняток виникає, якщо індекс під час звернення до елемента колекції знаходиться поза допустимим діапазоном

2. KeyError: виникає, якщо в словнику відсутній ключ, за яким відбувається звернення до елемента словника.

3. OverflowError: виникає, якщо результат арифметичної операції не може бути представлений поточним числовим типом (зазвичай типом float).

4. RecursionError: виникає, якщо перевищено допустиму глибину рекурсії.

5. TypeError: виникає, якщо операція або функція застосовується до значення неприпустимого типу.

6. ValueError: виникає, якщо операція або функція отримують об'єкт коректного типу з некоректним значенням.

7. ZeroDivisionError: виникає під час ділення на нуль.

8. NotImplementedError: тип винятку для вказівки, що якісь методи класу не реалізовані

9. ModuleNotFoundError: виникає при неможливості знайти модуль при його імпорті директивою import

10. OSError: тип винятків, що генеруються при виникненні помилок системи (наприклад, неможливо знайти файл, пам'ять диска заповнена тощо).

І якщо ситуація така, що в програмі можуть бути згенеровані різні типи винятків, то ми можемо їх обробити окремо, використовуючи додаткові вирази except. І при виникненні виключення Python буде шукати потрібний блок except, який обробляє даний тип виключення:


```python
try:
    number1 = int(input("Введіть перше число: "))
    number2 = int(input("Введіть друге число: "))
    print("Результат ділення:", number1/number2)
except ValueError:
    print("Перетворення пройшло невдало")
except ZeroDivisionError:
    print("Спроба ділення числа на нуль")
except BaseException:
    print("Загальне виключення")
print("Завершення програми")
```

    Введіть перше число: 1
    Введіть друге число: 0
    Спроба ділення числа на нуль
    Завершення програми
    

Якщо виникне виняток унаслідок перетворення рядка на число, то його буде оброблено блоком except ValueError. Якщо ж друге число дорівнюватиме нулю, тобто буде ділення на нуль, тоді виникне виняток ZeroDivisionError, і його буде оброблено блоком except ZeroDivisionError.

Тип BaseException представляє загальне виключення, під яке потрапляють усі виняткові ситуації. Тому в даному випадку будь-яке виключення, яке не представляє тип ValueError або ZeroDivisionError, буде опрацьоване в блоці except BaseException:.

Однак, якщо в програмі виникає виняток типу, для якого немає відповідного блоку except, то програма не зможе знайти відповідний блок except і згенерує виняток. Наприклад, у такому випадку:


```python
try:
    number1 = int(input("Введіть перше число: "))
    number2 = int(input("Введіть друге число: "))
    print("Результат ділення:", number1/number2)
except ZeroDivisionError:
    print("Спроба ділення числа на нуль")
print("Завершення програми")
```

    Введіть перше число: asf
    


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-11-6f04e6be858d> in <cell line: 1>()
          1 try:
    ----> 2     number1 = int(input("Введіть перше число: "))
          3     number2 = int(input("Введіть друге число: "))
          4     print("Результат ділення:", number1/number2)
          5 except ZeroDivisionError:
    

    ValueError: invalid literal for int() with base 10: 'asf'


Тут передбачено обробку ділення на нуль за допомогою блоку except ZeroDivisionError. Однак якщо користувач замість числа введе некорвертоване в число в рядок, то виникне виняток типу ValueError, для якого немає відповідного блоку except. І тому програма аварійно завершить своє виконання.

Python дозволяє в одному блоці except опрацьовувати одразу кілька типів винятків. У цьому випадку всі типи винятку передаються в дужках:


```python
try:
    number1 = int(input("Введіть перше число: "))
    number2 = int(input("Введіть друге число: "))
    print("Результат ділення:", number1/number2)
except (ZeroDivisionError, ValueError):    #  обробка двох типів винятків - ZeroDivisionError и ValueError
    print("Спроба ділення числа на нуль або некоректне введення")

print("Завершення програми")
```

    Введіть перше число: 123
    Введіть друге число: sdfsdf
    Спроба ділення числа на нуль або некоректне введення
    Завершення програми
    

## Отримання інформації про виключення
За допомогою оператора as ми можемо передати всю інформацію про виняток у змінну, яку потім можна використовувати в блоці except:



```python
try:
    number = int(input("Введіть число: "))
    print("Введене число:", number)
except ValueError as e:
    print("Відомості про виключення", e)
print("Завершення програми")
```

    Введіть число: wfsdfsdf
    Відомості про виключення invalid literal for int() with base 10: 'wfsdfsdf'
    Завершення програми
    

# Генерація винятків і створення своїх типів винятків
## Генерація винятків і оператор raise

Іноді виникає необхідність вручну згенерувати те чи інше виключення. Для цього застосовується оператор raise. Наприклад, згенеруємо виняток




```python
try:
    number1 = int(input("Введіть перше число: "))
    number2 = int(input("Введіть друге число: "))
    if number2 == 0:
        raise Exception("с=0")
    print("Результат ділення двох чисел:", number1/number2)
except ValueError:
    print("Введено некоректні дані")
except Exception as e:
    print(e)
print("Завершення програми")
```

    Введіть перше число: 123
    Введіть друге число: 0
    с=0
    Завершення програми
    

Оператору raise передається об'єкт BaseException - у цьому випадку об'єкт Exception. У конструктор цього типу можна йому передати повідомлення, яке потім можна вивести користувачеві. У підсумку, якщо number2 дорівнюватиме 0, то спрацює оператор raise, який згенерує виняток. У підсумку керування програмою перейде до блоку except, який обробляє винятки типу Exception

## Створення своїх типів винятків

У мові Python ми не обмежені тільки вбудованими типами винятків і можемо, застосовуючи успадкування, за необхідності створювати свої типи винятків. Наприклад, візьмемо наступний клас Person:


```python
class Person:
    def __init__(self, name, age):
        self.__name = name  # встановлюємо ім'я
        self.__age = age   # встановлюємо вік

    def display_info(self):
        print(f"Ім'я: {self.__name}  Вік: {self.__age}")
```

Тут клас Person у конструкторі отримує значення для імені та віку і присвоює їх приватним змінним name і age. Однак при створенні об'єкта Person ми можемо передати в конструктор некоректне з точки зору логіки значення - наприклад, від'ємне число. Одним зі способів розв'язання цієї ситуації є генерація винятку під час передавання некоректних значень.

Отже, визначимо такий код програми:


```python
class PersonAgeException(Exception):
    def __init__(self, age, minage, maxage):
        self.age = age
        self.minage = minage
        self.maxage = maxage

    def __str__(self):
        return f"Недопустиме значення: {self.age}. " \
               f"Вік має бути в діапазоні від {self.minage} до {self.maxage}"


class Person:
    def __init__(self, name, age):
        self.__name = name  # встановлюємо ім'я
        minage, maxage = 1, 110
        if minage < age < maxage:   # встановлюємо вік, якщо передано коректне значення
            self.__age = age
        else:                       # інакше генеруємо виняток
            raise PersonAgeException(age, minage, maxage)

    def display_info(self):
        print(f"Ім'я: {self.__name}  Вік: {self.__age}")

try:
    tom = Person("Tom", 37)
    tom.display_info()  # Ім'я: Tom Вік: 37

    bob = Person("Bob", -23)
    bob.display_info()
except PersonAgeException as e:
    print(e)    # Неприпустиме значення: -23. Вік має бути в діапазоні від 1 до 110
```

    Ім'я: Tom  Вік: 37
    Недопустиме значення: -23. Вік має бути в діапазоні від 1 до 110
    

На початку тут визначено клас PersonAgeException, який успадковується від класу Exception. Як правило, власні класи винятків успадковуються від класу Exception. Клас PersonAgeException призначений для винятків, пов'язаних із віком користувача.

У конструкторі PersonAgeException отримуємо три значення - власне некоректне значення, яке послужило причиною виключення, а також мінімальне і максимальне значення віку.



```python
class PersonAgeException(Exception):
    def __init__(self, age, minage, maxage):
        self.age = age
        self.minage = minage
        self.maxage = maxage

    def __str__(self):
        return f"Недопустиме значення: {self.age}. " \
               f"Вік має бути в діапазоні від {self.minage} до {self.maxage}"
```

У функції __str__ визначаємо текстове представлення класу - по суті повідомлення про помилку.

У конструкторі класу Persoon перевіряємо передане для віку користувача значення. І якщо це значення не відповідає певному діапазону, то генеруємо виняток типу PersonAgeException:
```
raise PersonAgeException(age, minage, maxage)
```
При застосуванні класу Person нам слід враховувати, що конструктор класу може згенерувати виняток при передачі некоректного значення. Тому створення об'єктів Person обгортається в конструкцію try...except:


```python
try:
    tom = Person("Tom", 37)
    tom.display_info()  # Ім'я: Tom Вік: 37

    bob = Person("Bob", -23)  # Генерується виняток типу PersonAgeException
    bob.display_info()
except PersonAgeException as e:
    print(e)    # Неприпустиме значення: -23. Вік має бути в діапазоні від 1 до 110
```

    Ім'я: Tom  Вік: 37
    Недопустиме значення: -23. Вік має бути в діапазоні від 1 до 110
    

І якщо під час виклику конструктора Person буде згенеровано виняток типу PersonAgeException, то керування програмою перейде до блоку except, який обробляє винятки типу PersonAgeException у вигляді виведення інформації про виняток на консоль.
