# Лекція 6.5. Інтерпретація скриптів. Модулі та типові пакети

# Модулі

Модуль у мові Python являє собою окремий файл із кодом, який можна повторно використовувати в інших програмах.

Для створення модуля необхідно створити власне файл із розширенням *.py, який представлятиме модуль. Назва файлу представлятиме назву модуля. Потім у цьому файлі треба визначити одну або кілька функцій.

Припустимо, основний файл програми називається main.py. І ми хочемо підключити до нього зовнішні модулі.

Для цього спочатку визначимо новий модуль: створимо в тій самій папці, де знаходиться main.py, новий файл, який назвемо message.py. Якщо використовується PyCharm або інша IDE, то обидва файли просто поміщаються в один проєкт.

Відповідно модуль називатиметься message. Визначимо в ньому такий код:


```python
hello = "Hello all"


def print_message(text):
    print(f"Message: {text}")
```


```python
with open("message.py", "w") as file:
    file.write('hello = "Hello all"\n\n')
    file.write('def print_message(text):\n')
    file.write('    print(f"Message: {text}")\n')
```

Тут визначено змінну hello і функцію print_message, яка як параметр отримує деякий текст і виводить його на консоль.

В основному файлі програми - main.py використовуємо цей модуль:


```python
import message      # підключаємо модуль message
# виводимо значення змінної hello
print(message.hello)        # Hello all
# звертаємося до функії print_message
message.print_message("Hello work")  # Message: Hello work
```

    Hello all
    Message: Hello work
    

Для використання модуля його треба імпортувати за допомогою оператора import, після якого вказується ім'я модуля: import message.

Щоб звертатися до функціональності модуля, нам потрібно отримати його простір імен. За замовчуванням він збігатиметься з іменем модуля, тобто в нашому випадку також називатиметься message.

Отримавши простір імен модуля, ми зможемо звернутися до його функцій за схемою

простір_імен.функція
Наприклад, звернення до функції print_message() з модуля message:


```python
message.print_message("Hello work")
```

    Message: Hello work
    

І після цього ми можемо запустити головний скрипт main.py, і він задіє модуль message.py.

## Підключення функціональності модуля в глобальний простір імен
Інший варіант налаштування передбачає імпорт функціональності модуля в глобальний простір імен поточного модуля за допомогою ключового слова from:


```python
from message import print_message

# звертаємося до функції print_message з модуля message
print_message("Hello work")  # Message: Hello work

# змінна hello з модуля message не доступна, оскільки вона не імпортована
# print(message.hello)
# print(hello)
```

    Message: Hello work
    

У цьому разі ми імпортуємо з модуля message у глобальний простір імен функцію print_message(). Тому ми зможемо її використовувати без вказівки простору імен модуля так, як якщо б вона була визначена в цьому ж файлі.

Усі інші функції, змінні з модуля недоступні (як наприклад, у прикладі вище змінна hello). Якщо ми хочемо їх також використовувати, то їх можна підключити окремо:


```python
from message import print_message
from message import hello

# звертаємося до функції print_message з модуля message
print_message("Hello work")  # Message: Hello work

# звертаємося до змінної hello з модуля message
print(hello)    # Hello all
```

    Message: Hello work
    Hello all
    

Якщо необхідно імпортувати в глобальний простір імен увесь функціонал, то замість назв окремих функцій і змінних можна використовувати символ зірочки *:


```python
from message import *

# звертаємося до функції print_message з модуля message
print_message("Hello work")  # Message: Hello work

# звертаємося до змінної hello з модуля message
print(hello)    # Hello all
```

    Message: Hello work
    Hello all
    

Але варто зазначити, що імпорт у глобальний простір імен загрожує колізіями імен функцій. Наприклад, якщо у нас у тому самому файлі визначено функцію з тим самим ім'ям до її виклику, то буде викликатися функція, яка визначена останньою:


```python
from message import *

print_message("Hello work")  # Message: Hello work - застосовується функція з модуля message

def print_message(some_text):
    print(f"Text: {some_text}")

print_message("Hello work")  # Text: Hello work - застосовується функція з поточного файлу
```

    Message: Hello work
    Text: Hello work
    

Таким чином, однойменна функція поточного файлу приховує функцію з підключеного модуля.

## Встановлення псевдонімів
Під час імпорту модуля та його функціональності ми можемо встановити для них псевдоніми. Для цього застосовується ключове слово as, після якого вказується псевдонім. Наприклад, встановимо псевдонім для модуля:


```python
import message as mes

print(mes.hello)        # Hello all
mes.print_message("Hello work")  # Message: Hello work
```

    Hello all
    Message: Hello work
    

У цьому разі простір імен називатиметься mes, і через цей псевдонім можна звертатися до функціональності модуля.

Подібним чином можна встановити псевдоніми для окремої функціональності модуля:


```python
from message import print_message as display
from message import hello as welcome

print(welcome)          # Hello all - змінна hello з модуля message
display("Hello work")   # Message: Hello work - функція print_message з модуля message
```

    Hello all
    Message: Hello work
    

Тут для функції print_message з модуля message встановлюється псевдонім display, а для змінної hello - псевдонім welcome. І через ці псевдоніми ми зможемо до них звертатися.

Псевдоніми можуть бути корисними, коли нас не влаштовують імена функцій і змінних, наприклад, вони надто довгі, і ми хочемо їх скоротити, або ми хочемо дати їм більш описові, з нашої точки зору, імена. Або якщо в поточному файлі вже є функціональність із тими самими іменами, і за допомогою встановлення псевдонімів ми можемо уникнути конфлікту імен. Наприклад:


```python
from message import print_message as display

def print_message(some_text):
    print(f"Text: {some_text}")

# функція print_message з модуля message
display("Hello work")       # Message: Hello work

# функція print_message з поточного файлу
print_message("Hello work")  # Text: Hello work
```

    Message: Hello work
    Text: Hello work
    

## Ім'я модуля
У прикладі вище модуль main.py, який є головним, використовує модуль message.py. Під час запуску модуля main.py програма виконає всю необхідну роботу. Однак, якщо ми запустимо окремо модуль message.py сам по собі, то нічого на консолі не побачимо. Адже модуль message просто визначає функцію та змінну і не виконує жодних інших дій. Але ми можемо зробити так, щоб модуль message.py міг використовуватися як сам по собі, так і підключатися в інші модулі.

Під час виконання модуля середовище визначає його ім'я і присвоює його глобальній змінній __name__ (з обох боків по два підкреслення). Якщо модуль є таким, що запускається, то його ім'я дорівнює __main__ (також по два підкреслення з кожного боку). Якщо модуль використовується в іншому модулі, то в момент виконання його ім'я аналогічне назві файлу без розширення py. І ми можемо це використовувати. Так, змінимо вміст файлу message.py:


```python
hello = "Hello all"


def print_message(text):
    print(f"Message: {text}")


def main():
    print_message(hello)


if __name__ == "__main__":
    main()
```

У цьому випадку в модуль message.py для тестування функціональності модуля додано функцію main. І ми можемо одразу запустити файл message.py окремо від усіх і протестувати код.

Слід звернути увагу на виклик функції main:


```python
if __name__ == "__main__":
    main()
```

Змінна __name__ вказує на ім'я модуля. Для головного модуля, який безпосередньо запускається, ця змінна завжди матиме значення __main__ незалежно від імені файлу.

Тому, якщо ми запускатимемо скрипт message.py окремо, сам по собі, то Python привласнить змінній __name__ значення __main__, далі у виразі if викличе функцію main із цього самого файлу.

Однак якщо ми запускатимемо інший скрипт, а цей - message.py - підключатимемо як допоміжний, для message.py змінна __name__ матиме значення message. І відповідно метод main у файлі message.py не працюватиме.

Цей підхід із перевіркою імені модуля є більш рекомендованим підходом, ніж просто виклик методу main.

У файлі main.py також можна зробити перевірку на те, чи є модуль головним (хоча в принципі це необов'язково):


```python
import message


def main():
    message.print_message("Hello work")  # Message: Hello work


if __name__ == "__main__":
    main()
```

Python надає низку вбудованих модулів, які ми можемо використовувати у своїх програмах.

# Додаткова інформація

Щоб конвертувати файл Jupyter Notebook (.ipynb) у файл вихідного коду Python (.py), можна скористатися інструментом командного рядка nbconvert, який постачається з Jupyter Notebook.

Ось як виконати конвертацію:

Відкрийте термінал або командний рядок.

Перейдіть у директорію, де знаходиться ваш файл .ipynb. Для цього можна використовувати команду "cd" у терміналі.

Запустіть команду nbconvert, вказавши ім'я файлу .ipynb і формат, у який потрібно виконати конвертацію (у цьому випадку - .py). Для цього введіть таку команду:
```
jupyter nbconvert --to python filename.ipynb
```

Де "filename.ipynb" - ім'я файлу Jupyter Notebook, який ви хочете конвертувати у файл вихідного коду Python.

Після виконання команди новий файл з ім'ям "filename.py" буде створено в тій самій директорії, де знаходиться файл .ipynb. Файл .py міститиме весь код на Python з файлу .ipynb у вигляді виконуваного скрипта мовою Python.

Зверніть увагу, що під час конвертації можуть загубитися деякі елементи форматування, як-от стилізація тексту або зображення, тому перед запуском конвертації рекомендується зберегти копію оригінального файлу .ipynb.
