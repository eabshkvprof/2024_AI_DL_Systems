# Лекція 6.6. Об'єктно-орієнтоване програмування. Проектування класів.

# Об'єктно-орієнтоване програмування в Python
Python має безліч вбудованих типів, наприклад, int, str тощо, які ми можемо використовувати в програмі. Але також Python дозволяє визначати власні типи за допомогою класів. Клас представляє деяку сутність. Конкретним втіленням класу є об'єкт.

Можна ще провести таку аналогію. У нас у всіх є певне уявлення про людину, яка має ім'я, вік, якісь інші характеристики Людина може виконувати деякі дії - ходити, бігати, думати тощо. Тобто це уявлення, яке включає набір характеристик і дій, можна назвати класом. Конкретне втілення цього шаблону може відрізнятися, наприклад, одні люди мають одне ім'я, інші - інше ім'я. І реально існуюча людина представлятиме об'єкт цього класу.

Клас визначається за допомогою ключового слова class:
```
class назва_класу:
    атрибути_класу
    методи_класу
```


Усередині класу визначаються його атрибути, які зберігають різні характеристики класу, і методи - функції класу.

Створимо найпростіший клас:


```python
class Person:
    pass
```

У цьому випадку визначено клас Person, який умовно представляє людину. У цьому випадку в класі не визначається жодних методів або атрибутів. Однак оскільки в ньому має бути щось визначено, то як замінник функціоналу класу застосовується оператор pass. Цей оператор застосовується, коли синтаксично необхідно визначити деякий код, проте ми не хочемо його, і замість конкретного коду вставляємо оператор pass.

Після створення класу можна визначити об'єкти цього класу. Наприклад:


```python
class Person:
    pass

tom = Person()      # визначення об'єкту tom
bob = Person()      # визначення об'єкту bob
print(type(tom))
```

    <class '__main__.Person'>
    

Після визначення класу Person створюються два об'єкти класу Person - tom і bob. Для створення об'єкта застосовується спеціальна функція - конструктор, яка називається за іменем класу і яка повертає об'єкт класу. Тобто в даному випадку виклик Person() являє собою виклик конструктора. Кожен клас за замовчуванням має конструктор без параметрів:


```python
tom = Person()      # Person() - виклик конструктора, який повертає об'єкт класу Person
```

## Методи класів
Методи класу фактично представляють функції, які визначені всередині класу і які визначають його поведінку. Наприклад, визначимо клас Person з одним методом:


```python
class Person:       # визначення класу Person
     def say_hello(self):
        print("Привіт")

tom = Person()
tom.say_hello()    # Привіт
```

    Привіт
    

Тут визначено метод say_hello(), який умовно виконує привітання - виводить рядок на консоль. Під час визначення методів будь-якого класу слід враховувати, що всі вони повинні приймати як перший параметр посилання на поточний об'єкт, який згідно з умовностями називається self. Через це посилання всередині класу ми можемо звернутися до функціональності поточного об'єкта. Але при самому виклику методу цей параметр не враховується.

Використовуючи ім'я об'єкта, ми можемо звернутися до його методів. Для звернення до методів застосовується нотація крапки - після імені об'єкта ставиться крапка і після неї йде виклик методу:
```
об'єкт.метод([параметри методу])
```

Наприклад, звернення до методу say_hello() для виведення привітання на консоль:


```python
tom.say_hello()    # Привіт
```

    Привіт
    

У підсумку ця програма виведе на консоль рядок "Привіт".

Якщо метод має приймати інші параметри, то вони визначаються після параметра self, і під час виклику подібного методу для них необхідно передати значення:


```python
class Person:       # визначення класу Person
    def say(self, message):     # метод
        print(message)

tom = Person()
tom.say("Привіт, друже!")    # Привіт, друже!
```

    Привіт, друже!
    

Тут визначено метод say(). Він приймає два параметри: self і message. І для другого параметра - message при виклику методу необхідно передати значення.

## self
Через ключове слово self можна звертатися всередині класу до функціональності поточного об'єкта:
```
self.атрибут    # звернення до атрибута
self.метод      # звернення до методу
```

Наприклад, визначимо два методи в класі Person:


```python
class Person:

    def say(self, message):
        print(message)

    def say_hello(self):
        self.say("Добрий день")  # звертаємося до вище визначеного методу say


tom = Person()
tom.say_hello()     # Добрий день
```

    Добрий день
    

Тут в одному методі - say_hello() викликається інший метод - say():
```
self.say("Добрий день")
```
Оскільки метод say() приймає крім self ще параметри (параметр message), то при виклику методу для цього параметра передається значення.

Причому при виклику методу об'єкта нам обов'язково необхідно використовувати слово self, якщо ми його не використовуємо:


```python
def say_hello(self):
    say("Hello work")  # ! Помилка
```

То ми зіткнемося з помилкою

## Конструктори
Для створення об'єкта класу використовується конструктор. Так, вище, коли ми створювали об'єкти класу Person, ми використовували конструктор за замовчуванням, який не приймає параметрів і який неявно мають усі класи:



```python
tom = Person()
```

Однак ми можемо явно визначити в класах конструктор за допомогою спеціального методу, який називається __init__() (по два прочерки з кожного боку). Наприклад, змінимо клас Person, додавши в нього конструктор:


```python
class Person:
    # конструктор
    def __init__(self):
        print("Створення об'єкта Person")

    def say_hello(self):
        print("Привіт")


tom = Person()      # Створення об'єкта Person
tom.say_hello()     # Привіт
```

    Створення об'єкта Person
    Привіт
    

Отже, тут у коді класу Person визначено конструктор і метод say_hello(). Як перший параметр конструктор, як і методи, також приймає посилання на поточний об'єкт - self. Зазвичай конструктори застосовуються для визначення дій, які мають виконуватися під час створення об'єкта.

Тепер під час створення об'єкта:


```python
tom = Person()
```

    Створення об'єкта Person
    

буде здійснюватися виклик конструктора __init__() з класу Person, який виведе на консоль рядок "Створення об'єкта Person".

## Атрибути об'єкта
Атрибути зберігають стан об'єкта. Для визначення та встановлення атрибутів усередині класу можна застосовувати слово self. Наприклад, визначимо такий клас Person:


```python
class Person:

    def __init__(self, name, age):
        self.name = name    # ім'я людини
        self.age = 1        # вік людини

tom = Person("Tom")

# звернення до атрибутів
# отримання значень
print(tom.name)     # Tom
print(tom.age)      # 1
# зміна значення
tom.age = 37
print(tom.age)      # 37
```

    Tom
    1
    37
    

Тепер конструктор класу Person приймає ще один параметр - name. Через цей параметр у конструктор буде передаватися ім'я створюваної людини.

Усередині конструктора встановлюються два атрибути - name і age (умовно ім'я і вік людини):
```
def __init__(self, name):
    self.name = name
    self.age = 1
```
Атрибуту self.name присвоюється значення змінної name. Атрибут age отримує значення 1.

Якщо ми визначили в класі конструктор __init__, ми вже не зможемо викликати конструктор за замовчуванням. Тепер нам треба викликати наш явно визначений конструктор __init__, в який необхідно передати значення для параметра name:


```python
tom = Person("Tom")
```

Далі за ім'ям об'єкта ми можемо звертатися до атрибутів об'єкта - отримувати і змінювати їхні значення:


```python
print(tom.name)     # отримання значення атрибута name
tom.age = 37        # зміна значення атрибута age
```

    Tom
    

У принципі нам необов'язково визначати атрибути всередині класу - Python дає змогу зробити це динамічно поза кодом:


```python
class Person:

    def __init__(self, name):
        self.name = name    # ім'я людини
        self.age = 1        # вік людини


tom = Person("Tom")

tom.company = "Microsoft"
print(tom.company)  # Microsoft
```

    Microsoft
    

Тут динамічно встановлюється атрибут company, який зберігає місце роботи людини. І після встановлення ми також можемо отримати його значення. Водночас подібне визначення загрожує помилками. Наприклад, якщо ми спробуємо звернутися до атрибута до його визначення, то програма згенерує помилку:


```python
tom = Person("Tom")
print(tom.company)  # ! Помилка - AttributeError: Person object has no attribute company
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-20-eab571b0fd14> in <cell line: 2>()
          1 tom = Person("Tom")
    ----> 2 print(tom.company)  # ! Помилка - AttributeError: Person object has no attribute company
    

    AttributeError: 'Person' object has no attribute 'company'


Для звернення до атрибутів об'єкта всередині класу в його методах також застосовується слово self:


```python
class Person:

    def __init__(self, name):
        self.name = name    # ім'я людини
        self.age = 1        # вік людини

    def display_info(self):
        print(f"Ім'я: {self.name}  Вік: {self.age}")


tom = Person("Tom")
tom.display_info()      # Ім'я: Tom  Вік: 1
```


    ---------------------------------------------------------------------------

    NameError                                 Traceback (most recent call last)

    <ipython-input-22-be6d8d32f574> in <cell line: 12>()
         10 
         11 tom = Person("Tom")
    ---> 12 tom.display_info()      # Ім'я: Tom  Вік: 1
    

    <ipython-input-22-be6d8d32f574> in display_info(self)
          6 
          7     def display_info(self):
    ----> 8         print(f"Ім'я: {name}  Вік: {self.age}")
          9 
         10 
    

    NameError: name 'name' is not defined


Тут визначається метод display_info(), який виводить інформацію на консоль. І для звернення в методі до атрибутів об'єкта застосовується слово self: self.name і self.age

## Створення об'єктів
Вище створювався один об'єкт. Але подібним чином можна створювати й інші об'єкти класу


```python
class Person:

    def __init__(self, name):
        self.name = name    # ім'я людини
        self.age = 1        # вік людини

    def display_info(self):
        print(f"Ім'я: {self.name}  Вік: {self.age}")


tom = Person("Tom")
tom.age = 37
tom.display_info()      # Ім'я: Tom  Вік: 37

bob = Person("Bob")
bob.age = 41
bob.display_info()      # Ім'я: Bob  Вік: 41
```

    Ім'я: Tom  Вік: 37
    Ім'я: Bob  Вік: 41
    

Тут створюються два об'єкти класу Person: tom і bob. Вони відповідають визначенню класу Person, мають однаковий набір атрибутів і методів, однак їхній стан відрізнятиметься.

Під час виконання програми Python динамічно визначатиме self - він представляє об'єкт, у якого викликається метод. Наприклад, у рядку:


```python
tom.display_info()      # Ім'я: Tom  Вік: 37
```

    Ім'я: Tom  Вік: 37
    

Це буде об'єкт tom, а при виклику


```python
bob.display_info()
```

    Ім'я: Bob  Вік: 41
    

Це буде об'єкт bob

# Інкапсуляція, атрибути та властивості
За замовчуванням атрибути в класах є загальнодоступними, а це означає, що з будь-якого місця програми ми можемо отримати атрибут об'єкта і змінити його. Наприклад:


```python
class Person:
    def __init__(self, name):
        self.name = name    # встановлюємо ім'я
        self.age = 1        # встановлюємо вік

    def display_info(self):
        print(f"Ім'я: {self.name}\tВік: {self.age}")


tom = Person("Tom")
tom.name = "Людина-павук"       # змінюємо атрибут name
tom.age = -129                  # змінюємо атрибут age
tom.surname = "Timovich"
tom.display_info()              # Ім'я: Людина-павук     Вік: -129
print(tom.surname)
```

    Ім'я: Людина-павук	Вік: -129
    Timovich
    

Але в цьому разі ми можемо, наприклад, присвоїти віку або імені людини некоректне значення, наприклад, вказати від'ємний вік. Така поведінка небажана, тому постає питання про контроль за доступом до атрибутів об'єкта.

З цією проблемою тісно пов'язане поняття інкапсуляції. Інкапсуляція є фундаментальною концепцією об'єктно-орієнтованого програмування. Вона запобігає прямому доступу до атрибутів об'єкта з коду, що викликає.

Щодо інкапсуляції безпосередньо в мові програмування Python приховати атрибути класу можна зробивши їх приватними або закритими та обмеживши доступ до них через спеціальні методи, які ще називаються властивостями.

Змінимо вище визначений клас, визначивши в ньому властивості:


```python
class Person:
    def __init__(self, name):
        self.__name = name  # встановлюємо ім'я
        self.__age = 1  # встановлюємо вік

    def set_age(self, age):
        if 1 < age < 110:
            self.__age = age
        else:
            print("Неприпустимий вік")

    def get_age(self):
        return self.__age

    def get_name(self):
        return self.__name

    def display_info(self):
        print(f"Ім'я: {self.__name}\tВік: {self.__age}")


tom = Person("Tom")
tom.display_info()  # Ім'я: Tom  Вік: 1
tom.set_age(-3486)  # Неприпустимий вік
tom.set_age(25)
tom.display_info()  # Ім'я: Tom  Вік: 25
```

    Ім'я: Tom	Вік: 1
    Неприпустимий вік
    Ім'я: Tom	Вік: 25
    25
    


```python
print(tom._Person__name) # Звернути увагу на питання інкапсуляції
```

    Tom
    

Для створення приватного атрибута на початку його найменування ставиться подвійний прочерк: self.__name. До такого атрибута ми зможемо звернутися тільки з того ж класу. Але не зможемо звернутися поза цим класом. Наприклад, присвоєння значення цьому атрибуту нічого не дасть:
```
tom.__age = 43
```
Тому що в цьому випадку просто визначається динамічно новий атрибут __age, але він не має нічого спільного з атрибутом self.__age.

А спроба отримати його значення призведе до помилки виконання (якщо раніше не була визначена змінна __age):


```python
print(tom.__age)
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-28-880053cab904> in <cell line: 1>()
    ----> 1 print(tom.__age)
    

    AttributeError: 'Person' object has no attribute '__age'


Однак все ж таки нам може знадобитися встановлювати вік користувача ззовні. Для цього створюються властивості. Використовуючи одну властивість, ми можемо отримати значення атрибута:


```python
def get_age(self):
    return self.__age
```

Цей метод ще часто називають геттер або аксесор. Для зміни віку визначено іншу властивість:


```python
def set_age(self, age):
    if 1 < age < 110:
        self.__age = age
    else:
        print("Неприпустимий вік")
```

Цей метод ще називають сеттер або мьютейтор (mutator). Тут ми вже можемо вирішити залежно від умов, чи треба перевстановлювати вік.

Необов'язково створювати для кожного приватного атрибута подібну пару властивостей. Так, у прикладі вище ім'я людини ми можемо встановити тільки з конструктора. А для отримання визначено метод get_name.

## Анотації властивостей
Вище ми розглянули, як створювати властивості. Але Python має також ще один - більш елегантний спосіб визначення властивостей. Цей спосіб передбачає використання анотацій, яким передує символ @.

Для створення властивості-геттера над властивістю ставиться анотація @property.

Для створення властивості-сеттера над властивістю встановлюється анотація ім'я_властивості_геттера.setter.

Перепишемо клас Person з використанням анотацій:


```python
class Person:
    def __init__(self, name):
        self.__name = name  # встановлюємо ім'я
        self.__age = 1  # встановлюємо вік

    @property
    def age(self):
        return self.__age

    @age.setter
    def age(self, age):
        if 1 < age < 110:
            self.__age = age
        else:
            print("Неприпустимий вік")

    @property
    def name(self):
        return self.__name

    def display_info(self):
        print(f"Ім'я: {self.__name}\tВік: {self.__age}")


tom = Person("Tom")

tom.display_info()  # Ім'я: Tom  Вік: 1
tom.age = -3486  # Неприпустимий вік
print(tom.age)  # 1
tom.age = 36
tom.display_info()  # Ім'я: Tom  Вік: 36
```

    Ім'я: Tom	Вік: 1
    Неприпустимий вік
    1
    Ім'я: Tom	Вік: 36
    

По-перше, варто звернути увагу, що властивість-сеттер визначається після властивості-геттера.

По-друге, і сеттер, і геттер називаються однаково - age. І оскільки геттер називається age, то над сетером встановлюється анотація @age.setter.

Після цього, що до геттера, що до сетера, ми звертаємося через вираз tom.age.

# Спадкування

Спадкування дає змогу створювати новий клас на основі вже наявного класу. Поряд з інкапсуляцією успадкування є одним із наріжних каменів об'єктно-орієнтованого програмування.

Ключовими поняттями успадкування є підклас і суперклас. Підклас успадковує від суперкласу всі публічні атрибути та методи. Суперклас ще називається базовим (base class) або батьківським (parent class), а підклас - похідним (derived class) або дочірнім (child class).

Синтаксис для успадкування класів виглядає таким чином:
```
class підклас (суперклас):
    методи_підкласу
```

Наприклад, у нас є клас Person, який представляє людину:


```python
class Person:

    def __init__(self, name):
        self.__name = name   # Ім'я людини

    @property
    def name(self):
        return self.__name

    def display_info(self):
        print(f"Ім'я: {self.__name} ")
```

Припустимо, нам необхідний клас працівника, який працює на деякому підприємстві. Ми могли б створити з нуля новий клас, наприклад, клас Employee:


```python
class Employee:

    def __init__(self, name):
        self.__name = name  # ім'я працівника

    @property
    def name(self):
        return self.__name

    def display_info(self):
        print(f"Ім'я: {self.__name} ")

    def work(self):
        print(f"{self.name} працює")
```

Однак клас Employee може мати ті самі атрибути і методи, що й клас Person, оскільки працівник - це людина. Так, у вищезазначеному в класі Employee тільки додається метод works, весь інший код повторює функціонал класу Person. Але щоб не дублювати функціонал одного класу в іншому, у цьому випадку краще застосувати успадкування.

Отже, успадкуємо клас Employee від класу Person:


```python
class Person:

    def __init__(self, name):
        self.__name = name   # ім'я людини

    @property
    def name(self):
        return self.__name

    def display_info(self):
        print(f"Ім'я: {self.__name} ")


class Employee(Person):

    def work(self):
        print(f"{self.name} працює")


tom = Employee("Tom")
print(tom.name)     # Tom
tom.display_info()  # Ім'я: Tom
tom.work()          # Tom працює
```

    Tom
    Ім'я: Tom 
    Tom працює
    

Клас Employee повністю переймає функціонал класу Person, лише додаючи метод work(). Відповідно при створенні об'єкта Employee ми можемо використовувати успадкований від Person конструктор:


```python
tom = Employee("Tom")
```

І також можна звертатися до успадкованих атрибутів/властивостей і методів:


```python
print(tom.name)     # Tom
tom.display_info()  # Ім'я: Tom
```

    Tom
    Ім'я: Tom 
    

Однак, варто звернути увагу, що для Employee НЕ доступні закриті атрибути типу __name. Наприклад, ми НЕ можемо в методі work звернутися до приватного атрибута self.__name:


```python
def work(self):
    print(f"{self.__name} works")   # ! Помилка
```

## Множинне успадкування
Однією з відмінних рис мови Python є підтримка множинного успадкування, тобто один клас можна успадкувати від кількох класів:


```python
# Клас працівника
class Employee:
    def work(self):
        print("Працівник працює")


# Клас студента
class Student:
    def study(self):
        print("Студент навчається")


class WorkingStudent(Employee, Student):        # Успадкування від класів Employee і Student
    pass


# Клас працюючого студента
tom = WorkingStudent()
tom.work()      # Працівник працює
tom.study()     # Студент навчається
```

    Працівник працює
    Студент навчається
    

Тут визначено клас Employee, який представляє співробітника фірми, і клас Student, який представляє студента, що навчається. Клас WorkingStudent, який представляє студента, що працює, не визначає жодного функціоналу, тому в ньому визначено оператор pass. Клас WorkingStudent просто успадковує функціонал від двох класів Employee і Student. Відповідно в об'єкта цього класу ми можемо викликати методи обох класів.

При цьому успадковані класи можуть бути складнішими за функціональністю, наприклад:


```python
class Employee:

    def __init__(self, name):
        self.__name = name

    @property
    def name(self):
        return self.__name

    def work(self):
        print(f"{self.name} працює")


class Student:

    def __init__(self, name):
        self.__name = name

    @property
    def name(self):
        return self.__name

    def study(self):
        print(f"{self.name} навчається")


class WorkingStudent(Employee, Student):
    pass


tom = WorkingStudent("Tom")
tom.work()      # Tom працює
tom.study()     # Tom навчається
```

    Tom працює
    Tom навчається
    

## Перевизначення функціоналу базового класу

В минулому розділі клас Employee повністю переймав функціонал класу Person:


```python
class Person:

    def __init__(self, name):
        self.__name = name   # Ім'я людини

    @property
    def name(self):
        return self.__name

    def display_info(self):
        print(f"Ім'я: {self.__name} ")


class Employee(Person):

    def work(self):
        print(f"{self.name} працює")
```

Але що, якщо ми хочемо щось змінити з цього функціоналу? Наприклад, додати працівнику через конструктор новий атрибут, який зберігатиме компанію, де він працює, або змінити реалізацію методу display_info. Python дозволяє перевизначити функціонал базового класу.

Наприклад, змінимо класи таким чином:


```python
class Person:

    def __init__(self, name):
        self.__name = name   # Ім'я людини

    @property
    def name(self):
        return self.__name

    def display_info(self):
        print(f"Ім'я: {self.__name}")


class Employee(Person):

    def __init__(self, name, company):
        super().__init__(name)
        self.company = company

    def display_info(self):
        super().display_info()
        print(f"Компанія: {self.company}")

    def work(self):
        print(f"{self.name} працює")


tom = Employee("Tom", "Microsoft")
tom.display_info()  # Ім'я: Tom
                    # Компанія: Microsoft
```

    Ім'я: Tom
    Компанія: Microsoft
    


```python
print(tom._Person__name)
```


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-56-dcbba1e526b9> in <cell line: 1>()
    ----> 1 print(tom._Person__name)
    

    AttributeError: 'Person' object has no attribute '_Person__name'


Тут у класі Employee додається новий атрибут - self.company, який зберігає компанію працівника. Відповідно метод __init__() приймає три параметри: другий для встановлення імені і третій для встановлення компанії. Але якщо в базовому класі визначено конструктор за допомогою методу __init__, і ми хочемо в похідному класі змінити логіку конструктора, то в конструкторі похідного класу ми повинні викликати конструктор базового класу. Тобто в конструкторі Employee треба викликати конструктор класу Person.

Для звернення до базового класу використовується вираз super(). Так, у конструкторі Employee виконується виклик:
```
super().__init__(name)
```
Цей вираз буде представляти виклик конструктора класу Person, в який передається ім'я працівника. І це логічно. Адже ім'я працівника встановлюється саме в конструкторі класу Person. У самому конструкторі Employee лише встановлюємо властивість company.

Крім того, у класі Employee перевизначається метод display_info() - у нього додається виведення компанії працівника. Причому ми могли визначити цей метод таким чином:


```python
def display_info(self):
    print(f"Ім'я: {self.name}")
    print(f"Компанія: {self.company}")
```

Але тоді рядок виведення імені повторював би код із класу Person. Якщо ця частина коду збігається з методом із класу Person, то немає сенсу повторюватися, тому знову ж таки за допомогою виразу super() звертаємося до реалізації методу display_info в класі Person:


```python
def display_info(self):
    super().display_info()      # звернення до методу display_info в класі Person
    print(f"Company: {self.company}")
```

Потім ми можемо викликати конструктор Employee для створення об'єкта цього класу і викликати метод display_info:


```python
tom = Employee("Tom", "Microsoft")
tom.display_info()
```

## Перевірка типу об'єкта

Під час роботи з об'єктами буває необхідно залежно від їхнього типу виконати ті чи інші операції. І за допомогою вбудованої функції isinstance() ми можемо перевірити тип об'єкта. Ця функція приймає два параметри:
```
isinstance(object, type)
```

Перший параметр представляє об'єкт, а другий - тип, на приналежність до якого виконується перевірка. Якщо об'єкт представляє зазначений тип, то функція повертає True. Наприклад, візьмемо таку ієрархію класів Person-Employee/Student:


```python
class Person:

    def __init__(self, name):
        self.__name = name   # Ім'я людини

    @property
    def name(self):
        return self.__name

    def do_nothing(self):
        print(f"{self.name} нічого не робить")


# Клас працівника
class Employee(Person):

    def work(self):
        print(f"{self.name} працює")


# Клас студента
class Student(Person):

    def study(self):
        print(f"{self.name} навчається")


def act(person):
    if isinstance(person, Student):
        person.study()
    elif isinstance(person, Employee):
        person.work()
    elif isinstance(person, Person):
        person.do_nothing()


tom = Employee("Tom")
bob = Student("Bob")
sam = Person("Sam")

act(tom)    # Tom працює
act(bob)    # Bob навчається
act(sam)    # Sam нічого не робить
```

    Tom працює
    Bob навчається
    Sam нічого не робить
    

Тут клас Employee визначає метод work(), а клас Student - метод study.

Тут також визначена функція act, яка перевіряє за допомогою функції isinstance, чи представляє параметр person певний тип, і залежно від результатів перевірки звертається до певного методу об'єкта.


# Атрибути класів і статичні методи
## Атрибути класу
Крім атрибутів об'єктів у класі можна визначати атрибути класів. Подібні атрибути визначаються у вигляді змінних рівня класу. Наприклад:



```python
class Person:
     type = "Людина"
     description = "Описує людину"


print(Person.type)          # Людина
print(Person.description)   # Описує людину

Person.type = "Клас людини"
print(Person.type)          # Клас людини
```

    Людина
    Описує людину
    Клас людини
    

Тут у класі Person визначено два атрибути: type, який зберігає ім'я класу, і description, який зберігає опис класу.

Для звернення до атрибутів класу ми можемо використовувати ім'я класу, наприклад: Person.type, і, як і атрибути об'єкта, ми можемо отримувати та змінювати їхні значення.

Подібні атрибути є спільними для всіх об'єктів класу:


```python
class Person:
     type = "Людина"
     def __init__(self, name):
         self.name = name
         self.__age = 2


tom = Person("Tom")
bob = Person("Bob")
print(tom.type)     # Людина
print(bob.type)     # Людина

# Змінимо атрибут класу
Person.type = "Клас людини"
print(tom.type)     # Class Person
print(bob.type)     # Class Person
```

    Людина
    Людина
    Клас людини
    Клас людини
    

Атрибути класу можуть застосовуватися для таких ситуацій, коли нам треба визначити деякі загальні дані для всіх об'єктів. Наприклад:


```python
class Person:
    default_name = "Undefined"

    def __init__(self, name):
        if name:
            self.name = name
        else:
            self.name = Person.default_name


tom = Person("Tom")
bob = Person("")
print(tom.name)  # Tom
print(bob.name)  # Undefined
```

    Tom
    Undefined
    

У цьому випадку атрибут default_name зберігає ім'я за замовчуванням. І якщо в конструктор передано порожній рядок для імені, то атрибуту name передається значення атрибута класу default_name. Для звернення до атрибута класу всередині методів можна застосовувати ім'я класу
```
self.name = Person.default_name
```


## Атрибут класу
Можлива ситуація, коли атрибут класу й атрибут об'єкта збігається за іменем. Якщо в коді для атрибута об'єкта не задано значення, то для нього може застосовуватися значення атрибута класу:


```python
class Person:
    name = "Undefined"

    def print_name(self):
        print(self.name)


tom = Person()
bob = Person()
tom.print_name()    # Undefined
bob.print_name()    # Undefined

bob.name = "Bob"
bob.print_name()    # Bob
tom.print_name()    # Undefined
```

    Undefined
    Undefined
    Bob
    Undefined
    

Тут метод print_name використовує атрибут об'єкт name, проте ніде в коді цей атрибут не встановлюється. Натомість на рівні класу задано атрибут name. Тож при першому зверненні до методу print_name, у ньому використовуватиметься значення атрибута класу:


```python
tom = Person()
bob = Person()
tom.print_name()    # Undefined
bob.print_name()    # Undefined
```

    Undefined
    Undefined
    

Однак далі ми можемо поміняти встановити атрибут об'єкта:


```python
bob.name = "Bob"
bob.print_name()    # Bob
tom.print_name()    # Undefined
```

    Bob
    Undefined
    

Причому другий об'єкт - tom продовжить використовувати атрибут класу. І якщо ми змінимо атрибут класу, відповідно значення tom.name теж зміниться:


```python
tom = Person()
bob = Person()
tom.print_name()    # Undefined
bob.print_name()    # Undefined

Person.name = "Якась людина"     # змінюємо значення атрибута класу
bob.name = "Bob"                # встановлюємо атрибут об'єкта
bob.print_name()    # Bob
tom.print_name()    # Якась людина
```

    Undefined
    Undefined
    Bob
    Якась людина
    

## Статичні методи
Крім звичайних методів клас може визначати статичні методи. Таким методам передує анотація @staticmethod, і вони відносяться загалом до класу. Статичні методи зазвичай визначають поведінку, яка не залежить від конкретного об'єкта:


```python
class Person:
    __type = "Людина"

    @staticmethod
    def print_type():
        print(Person.__type)


Person.print_type()     # Людина - звернення до статичного методу через ім'я класу

tom = Person()
tom.print_type()     # Людина - звернення до статичного методу через ім'я об'єкта
```

    Людина
    Людина
    

У цьому випадку в класі Person визначено атрибут класу __type, який зберігає значення, загальне для всього класу - назву класу. Причому оскільки назва атрибута передує двом підкресленням, то цей атрибут буде приватним, що захистить від неприпустимої зміни.

Також у класі Person визначено статичний метод print_type, який виводить на консоль значення атрибута __type. Дія цього методу не залежить від конкретного об'єкта і стосується загалом усього класу - незалежно від об'єкта на консоль виводитиметься одне й те саме значення атрибута __type. Тому такий метод можна зробити статичним.

# Клас object. Строкове представлення об'єкта
Починаючи з 3-ї версії в мові програмування Python усі класи неявно мають один загальний суперклас - object і всі класи за замовчуванням успадковують його методи.

Одним з найбільш використовуваних методів класу object є метод __str__(). Коли необхідно отримати строкове представлення об'єкта або вивести об'єкт у вигляді рядка, то Python якраз викликає цей метод. І під час визначення класу гарною практикою вважається перевизначення цього методу.

Наприклад, візьмемо клас Person і виведемо його строкове представлення:


```python
class Person:
    def __init__(self, name, age):
        self.name = name  # встановлюємо ім'я
        self.age = age  # встановлюємо вік

    def display_info(self):
        print(f"Ім'я: {self.name}  Вік: {self.age}")


tom = Person("Tom", 23)
print(tom)
```

    <__main__.Person object at 0x7f1d62bf8370>
    

Під час запуску програма виведе щось на кшталт такого:
```
<__main__.Person object at 0x10a63dc00>
```
Це не дуже інформативна інформація про об'єкт. Ми, звісно, можемо вийти з положення, визначивши в класі Person додатковий метод, який виводить дані об'єкта - у прикладі вище це метод display_info.

Але є й інший вихід - визначимо в класі Person метод __str__() (по два підкреслення з кожного боку):


```python
class Person:
    def __init__(self, name, age):
        self.name = name  # встановлюємо ім'я
        self.age = age  # встановлюємо вік

    def display_info(self):
        print(self)
        # print(self.__str__())     # або так

    def __str__(self):
        return f"Ім'я: {self.name}  Вік: {self.age}"

tom = Person("Tom", 23)
print(tom)      # Ім'я: Tom  Вік: 23
tom.display_info()  # Ім'я: Tom  Ві: 23
```

    Ім'я: Tom  Вік: 23
    Ім'я: Tom  Вік: 23
    

Метод __str__ має повертати рядок. І в цьому випадку ми повертаємо базову інформацію про людину. Якщо нам буде потрібно використовувати цю інформацію в інших методах класу, то ми можемо використовувати вираз self.__str__()
