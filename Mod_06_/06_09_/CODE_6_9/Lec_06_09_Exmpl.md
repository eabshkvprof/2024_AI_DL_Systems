# Лекція 6.9. Базові бібліотечні модулі. Пакети для роботи зі штучним інтелектом

# Вбудовані модулі Python
## Модуль sys
Модуль sys надає системі особливі параметри та функції. У цьому розділі ми розглянемо таке:
1. sys.argv
2. sys.executable
3. sys.exit
4. sys.modules
5. sys.path
6. sys.platform
7. sys.stdin/stdout/stderr
8. sys.prefix
9. sys.version


```python
import sys
```

### sys.argv
Значення sys.argv - це список аргументів командного рядка, які причетні до скрипта Python. Перший аргумент, argv[0], має аналогічне скрипту Python найменування. Залежно від платформи, на якій ви працюєте, перший аргумент може містити повний шлях до скрипта або до назви файлу. Для додаткових деталей зверніться до документації.


```python
print(sys.argv)
```

    ['/usr/local/lib/python3.10/dist-packages/colab_kernel_launcher.py', '-f', '/root/.local/share/jupyter/runtime/kernel-ec6327a1-18b5-41a2-b89c-dca6f41a3771.json']
    

### sys.executable
Значення sys.executable - це повний шлях до інтерпретатора Python. Це дуже корисно, коли ви використовуєте чийсь комп'ютер, і вам потрібно дізнатися, де встановлено Python. У деяких системах ця команда не спрацює, і видасть порожній рядок із написом None.


```python
print(sys.executable)
```

    /usr/bin/python3
    

### sys.exit
Ця функція дозволяє розробнику вийти з Python. Функція exit приймає необов'язковий аргумент, зазвичай ціле число, яке дає статус виходу. Нуль вважається як успішне завершення. Обов'язково перевірте, чи має ваша операційна система якісь особливі значення для своїх статусів виходу, щоб ви могли слідкувати за ними у своєму власному застосунку. Зверніть увагу на те, що коли ви викликаєте exit, це спричинить виняток SystemExit, який дозволяє функціям очищення працювати в кінцевих пунктах блоків try / except.


```python
sys.exit(0)
```


    An exception has occurred, use %tb to see the full traceback.
    

    SystemExit: 0
    


    /usr/local/lib/python3.10/dist-packages/IPython/core/interactiveshell.py:3561: UserWarning: To exit: use 'exit', 'quit', or Ctrl-D.
      warn("To exit: use 'exit', 'quit', or Ctrl-D.", stacklevel=1)
    

### sys.path
Значення функції path модуля sys - це список рядків, які вказують шлях пошуку для модулів. Як правило, ця функція вказує Python, в яких локаціях дивитися, коли він намагається імпортувати модуль. Відповідно до документації Python, sys.path ініціалізується зі змінної оточення PYTHONPATH, плюс залежне від установки значення, вказане за замовчуванням.


```python
print(sys.path)
```

    ['/content', '/env/python', '/usr/lib/python310.zip', '/usr/lib/python3.10', '/usr/lib/python3.10/lib-dynload', '', '/usr/local/lib/python3.10/dist-packages', '/usr/lib/python3/dist-packages', '/usr/local/lib/python3.10/dist-packages/IPython/extensions', '/root/.ipython']
    

### sys.platform
Значення sys.platform - ідентифікатор платформи. Ви можете використовувати sys.platform, щоб додавати модулі до sys.path, імпортувати різні модулі, залежно від платформи, або запускати різні частини коду.


```python
print(sys.platform)
```

    linux
    

### sys.stdin / stdout / stderr
Stdin, stdout і stderr зіставляються з файловими об'єктами, які відповідають стандартним входам, виходам і потокам помилок інтерпретатора відповідно. Функція stdin використовується для всіх входів, що використовуються інтерпретатором, за винятком скриптів, тоді як stdout використовується для виходів операторів print і expression. Головна причина, з якої я акцентую на цьому увагу, полягає в тому, що в якийсь момент вам потрібно буде переспрямувати stdout чи stderr або обидві функції до файлу, такого як log, або ж до будь-якого дисплея в користувацькому графічному інтерфейсі, створеному вами. Ви також можете перенаправити stdin, але з такими випадками я практично не стикався.

### sys.version
Рядок, що містить номер версії інтерпретатора Python, а також додаткову інформацію про номер збірки та використаний компілятор. Цей рядок відображається під час запуску інтерактивного інтерпретатора. Не витягуйте з нього інформацію про версію, натомість використовуйте version_info та функції, що надаються модулем платформи.


```python
print(sys.version)
```

    3.9.16 (main, Dec  7 2022, 01:11:51) 
    [GCC 9.4.0]
    

### sys.prefix
Рядок, що містить префікс каталогу, до якого встановлено незалежні від платформи файли Python; на Unix за замовчуванням це /usr/local. Його можна встановити під час збирання за допомогою аргументу --prefix до скрипту конфігурації.


```python
print(sys.prefix)
```

    /usr
    

## Модуль math
Вбудований модуль math у Python надає набір функцій для виконання математичних, тригонометричних і логарифмічних операцій. Деякі з основних функцій модуля:
1. pow(num, power): піднесення числа num до степеня power
2. sqrt(num): квадратний корінь числа num
3. ceil(num): округлення числа до найближчого найбільшого цілого
4. floor(num): округлення числа до найближчого найменшого цілого
5. factorial(num): факторіал числа
6. degrees(rad): переведення з радіан у градуси
7. radians(grad): переведення з градусів у радіани
8. cos(rad): косинус кута в радіанах
9. sin(rad): синус кута в радіанах
10. tan(rad): тангенс кута в радіанах
11. acos(rad): арккосинус кута в радіанах
12. asin(rad): арксинус кута в радіанах
13. atan(rad): арктангенс кута в радіанах
14. log(n, base): логарифм числа n за основою base
15. log10(n): десятковий логарифм числа n


```python
import math

# піднесення числа 2 до степеня 3
n1 = math.pow(2, 3)
print(n1)  # 8

# ту ж саму операцію можна виконати так
n2 = 2**3
print(n2)

# квадратний корінь числа
print(math.sqrt(9))  # 3

# найближче найбільше ціле число
print(math.ceil(4.56))  # 5

# найближче найменше ціле число
print(math.floor(4.56))  # 4

# переведення з радіан у градуси
print(math.degrees(3.14159))  # 180

# переведення з градусів у радіани
print(math.radians(180))   # 3.1415.....
# косинус
print(math.cos(math.radians(60)))  # 0.5
# cинус
print(math.sin(math.radians(90)))   # 1.0
# тангенс
print(math.tan(math.radians(0)))    # 0.0

print(math.log(8,2))    # 3.0
print(math.log10(100))    # 2.0
```

    8.0
    8
    3.0
    5
    4
    179.9998479605043
    3.141592653589793
    0.5000000000000001
    1.0
    0.0
    3.0
    2.0
    

Також модуль math надає низку вбудованих констант, такі як PI та E:


```python
radius = 30
# площа кола з радіусом 30
area = math.pi * math.pow(radius, 2)
print(area)

# натуральний логарифм числа 10
number = math.log(10, math.e)
print(number)
```

    2827.4333882308138
    2.302585092994046
    

## Модуль Random

Модуль random керує генерацією випадкових чисел. Його основні функції:

1. random(): генерує випадкове число від 0.0 до 1.0
2. randint(): повертає випадкове число з певного діапазону
3. randrange(): повертає випадкове число з певного набору чисел
4. shuffle(): перемішує список
5. choice(): повертає випадковий елемент списку

Функція random() повертає випадкове число з плаваючою крапкою в проміжку від 0.0 до 1.0. Якщо ж нам потрібне число з більшого діапазону, скажімо від 0 до 100, то ми можемо відповідно помножити результат функції random на 100.



```python
import random
#random.seed(42)
number = random.random()  # значення від 0.0 до 1.0
print(number)
number = random.random() * 100  # значення від 0.0 до 100.0
print(number)
```

    0.4320457250640817
    65.19182275876932
    

Функція randint(min, max) повертає випадкове ціле число в проміжку між двома значеннями min і max.


```python
number = random.randint(20, 35)  # значення від 20 до 35
print(number)
```

    28
    

Функція randrange() повертає випадкове ціле число з певного набору чисел. Вона має три форми:

1. randrange(stop): як набір чисел, з яких відбувається витяг випадкового значення, буде використовуватися діапазон від 0 до числа stop

2. randrange(start, stop): набір чисел представляє діапазон від числа start до числа stop

3. randrange(start, stop, step): набір чисел представляє діапазон від числа start до числа stop, при цьому кожне число в діапазоні відрізняється від попереднього на крок step


```python
number = random.randrange(10)  # значення від 0 до 10 не включаючи
print(number)
number = random.randrange(2, 10)  # значення в діапазоні 2, 3, 4, 5, 6, 7, 8, 9
print(number)
number = random.randrange(2, 10, 2)  # значення в діапазоні 2, 4, 6, 8
print(number)
```

    7
    6
    6
    

### Робота зі списком
Для роботи зі списками в модулі random визначено дві функції: функція shuffle() перемішує список випадковим чином, а функція choice() повертає один випадковий елемент зі списку:


```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8]
random.shuffle(numbers)
print(numbers)
random_number = random.choice(numbers)
print(random_number)
```

    [6, 4, 7, 1, 8, 2, 3, 5]
    2
    

## Модуль datetime
Основний функціонал для роботи з датами і часом зосереджений у модулі datetime у вигляді таких класів:

1. date
2. time
3. datetime

### Клас date
Для роботи з датами скористаємося класом date, який визначено в модулі datetime. Для створення об'єкта date ми можемо використовувати конструктор date, який послідовно приймає три параметри: рік, місяць і день.

```date(year, month, day)```

Наприклад, створимо якусь дату:


```python
import datetime

yesterday = datetime.date(2024,3, 31)
print(yesterday)      # 2017-05-02
```

    2024-03-31
    

Якщо необхідно отримати поточну дату, то можна скористатися методом today():


```python
from datetime import date

today = date.today()
print(today)
print("{}.{}.{}".format(today.day, today.month, today.year))
```

    2024-04-01
    1.4.2024
    

За допомогою властивостей day, month, year можна отримати відповідно день, місяць і рік

### Клас time
За роботу з часом відповідає клас time. Використовуючи його конструктор, можна створити об'єкт часу:

```time([hour] [, min] [, sec] [, microsec])```

Конструктор послідовно приймає години, хвилини, секунди та мікросекунди. Усі параметри необов'язкові, і якщо ми якийсь параметр не передамо, то відповідне значення ініціалізуватиметься нулем.


```python
from datetime import time

current_time = time()
print(current_time)     # 00:00:00

current_time = time(16, 25)
print(current_time)     # 16:25:00

current_time = time(16, 25, 45, 30)
print(current_time)     # 16:25:45
```

    00:00:00
    16:25:00
    16:25:45.000030
    

### Клас datetime
Клас datetime з однойменного модуля об'єднує можливості роботи з датою і часом. Для створення об'єкта datetime можна використовувати такий конструктор:

```datetime(year, month, day [, hour] [, min] [, sec] [, microsec])```

Перші три параметри, що представляють рік, місяць і день, є обов'язковими. Решта необов'язкові, і якщо ми не вкажемо для них значення, то за замовчуванням вони ініціалізуються нулем.


```python
from datetime import datetime

deadline = datetime(2017, 5, 10)
print(deadline)     # 2017-05-10 00:00:00

deadline = datetime(2017, 5, 10, 4, 30)
print(deadline)     # 2017-05-10 04:30:00
```

    2017-05-10 00:00:00
    2017-05-10 04:30:00
    

Для отримання поточних дати і часу можна викликати метод now():


```python
now = datetime.now()
print(now)

print("{}-{}.{}  {}:{}".format(now.day, now.month, now.year, now.hour, now.minute))

print(now.date())
print(now.time())
```

    2024-04-01 09:00:53.184143
    1-4.2024  9:0
    2024-04-01
    09:00:53.184143
    

За допомогою властивостей day, month, year, hour, minute, second можна отримати окремі значення дати та часу. А через методи date() і time() можна отримати окремо дату і час відповідно.

### Перетворення з рядка на дату
З функціональності класу datetime слід зазначити метод strptime(), який дає змогу розпарсити рядок і перетворити його на дату. Цей метод приймає два параметри:

```strptime(str, format)```

Перший параметр str представляє строкове визначення дати і часу, а другий параметр - формат, який визначає, як різні частини дати і часу розташовані в цьому рядку.

Для визначення формату ми можемо використовувати такі коди:

1. %d: день місяця у вигляді числа

2. %m: порядковий номер місяця

3. %y: рік у вигляді 2-х чисел

4. %Y: рік у вигляді 4-х чисел

5. %H: година у 24-х годинному форматі

6. %M: хвилина

7. %S: секунда

Застосуємо різні формати:


```python
deadline = datetime.strptime("22/05/2017", "%d/%m/%Y")
print(deadline)     # 2017-05-22 00:00:00

deadline = datetime.strptime("22/05/2017 12:30", "%d/%m/%Y %H:%M")
print(deadline)     # 2017-05-22 12:30:00

deadline = datetime.strptime("05-22-2017 12:30", "%m-%d-%Y %H:%M")
print(deadline)     # 2017-05-22 12:30:00
```

    2017-05-22 00:00:00
    2017-05-22 12:30:00
    2017-05-22 12:30:00
    

# Numpy
NumPy - це open-source модуль для python, який надає загальні математичні та числові операції у вигляді пре-компільованих, швидких функцій. Вони об'єднуються у високорівневі пакети. Вони забезпечують функціонал, який можна порівняти з функціоналом MatLab. NumPy (Numeric Python) надає базові методи для маніпуляції з великими масивами та матрицями. SciPy (Scientific Python) розширює функціонал numpy величезною колекцією корисних алгоритмів, таких як мінімізація, перетворення Фур'є, регресія, та інші прикладні математичні техніки.

Чим корисна бібліотека?
1. Ефективні та зручні інструменти для роботи з числовими масивами (array)
2. Математичні функції та константи (не потрібен модуль math стандартної бібліотеки)
3. Робота з випадковими вибірками (не потрібен модуль random стандартної бібліотеки)
4. Деякі базові речі з лінійної алгебри

Чим відрізняється масив (array) від списку (list)?
1. Список (базовий тип у Python) може містити елементи різних типів, мати довільну як завгодно складну структуру.
При цьому продуктивність списків (швидкість їхньої обробки) нижча, ніж нам би хотілося. Особливо це відчувається під час роботи з великими даними (сотні тисяч елементів і більше).
2. Для обробки списків нам завжди потрібен for-цикл, а for-цикли в Python працюють повільно (якщо йдеться про мільйони ітерацій, то це буде відчуватися).
3. Масив (array) --- це новий тип даних, що надається бібліотекою NumPy.
4. Масив --- це колекція елементів одного типу (основна відмінність!) довільної довжини. Масиви бувають одно-, дво- і багатовимірні, при цьому розмірність розуміється в математичному сенсі як розмірність простору.
5. Одновимірний масив, на відміну від списку, більше схожий на вектор --- математичний об'єкт.
6. Двовимірний масив --- це матриця в математичному сенсі.
7. Для роботи з масивами в NumPy реалізовано безліч вбудованих функцій, що нагадують математичні операції над векторами і матрицями: поелементні (векторизовані) математичні операції, скалярний добуток, матричний добуток, норма тощо.
8. Під час обробки NumPy-масивів не потрібні for-цикли. Їх використання, взагалі кажучи, не рекомендується через низьку продуктивність.

# Імпорт модуля numpy
Є кілька шляхів імпорту. Стандартний метод це - використовувати простий вираз:


```python
import numpy
```

Проте, для великої кількості викликів функцій numpy, стає утомливо писати numpy.X знову і знову. Замість цього набагато легше зробити це так:


```python
import numpy as np
```

Цей вираз дозволяє нам отримувати доступ до numpy об'єктів, використовуючи np.X замість numpy.X. Також можна імпортувати numpy прямо у простір імен, який використовується, щоб взагалі не використовувати функції через крапку, а викликати їх безпосередньо:


```python
from numpy import *
```

Однак, цей варіант не вітається в програмуванні на python, оскільки прибирає деякі корисні структури, які модуль надає. До кінця цього туторіалу ми будемо використовувати другий варіант імпорту (import numpy as np).

# Масиви
Головною особливістю numpy є об'єкт array. Масиви схожі зі списками в python, за винятком того факту, що елементи масиву повинні мати однаковий тип даних, як float і int. З масивами можна проводити числові операції з великим обсягом інформації в рази швидше і, головне, набагато ефективніше ніж зі списками.

Створення масиву зі списку:


```python
import numpy as np

a = np.array([1, 4, 5, 8], float)
print(a)
print(type(a))
```

    [1. 4. 5. 8.]
    <class 'numpy.ndarray'>
    

Тут функція array приймає два аргументи: список для конвертації в масив і тип для кожного елемента. До всіх елементів можна отримати доступ і маніпулювати ними так само, як ви б це робили зі звичайними списками:


```python
print(a[:2])
print(a[3])
a[0] = 5
print(a)
```

    [5. 4.]
    8.0
    [5. 4. 5. 8.]
    

Масиви можуть бути і багатовимірними. На відміну від списків можна використовувати коми в дужках. Ось приклад двовимірного масиву (матриця):


```python
a = np.array([[1, 2, 3], [4, 5, 6]], float)
print(a)
print(a[0,0])
print(a[0,1])
```

    [[1. 2. 3.]
     [4. 5. 6.]]
    1.0
    2.0
    

Array slicing працює з багатовимірними масивами аналогічно, як і з одновимірними, застосовуючи кожен зріз як фільтр для встановленого виміру. Використовуйте ":" у вимірі для вказування використання всіх елементів цього виміру:


```python
a = np.array([[1, 2, 3], [4, 5, 6]], float)
print(a[1,:])
print(a[:,2])
print(a[-1:, -2:])
```

    [4. 5. 6.]
    [3. 6.]
    [[5. 6.]]
    

Метод shape повертає кількість рядків і стовпців у матриці:


```python
print(a)
```

    [[1. 2. 3.]
     [4. 5. 6.]]
    


```python
print(a.shape)
```

    (2, 3)
    

Метод dtype повертає тип змінних, що зберігаються в масиві:


```python
print(a.dtype)
```

    float64
    

Тут float64, це числовий тип даних у numpy, який використовується для зберігання дійсних чисел подвійної точності. Так само як float у Python.

Метод len повертає довжину першого виміру (осі):


```python
a = np.array([[1, 2, 3], [4, 5, 6]], float)
print(len(a))
```

    2
    

Метод in використовується для перевірки на наявність елемента в масиві:


```python
a = np.array([[1, 2, 3], [4, 5, 6]], float)
print(2 in a)
print(0 in a)
```

    True
    False
    

Масиви можна переформувати за допомогою методу, який задає новий багатовимірний масив. Дотримуючись наступного прикладу, ми переформатуємо одновимірний масив із десяти елементів у двовимірний масив, що складається з п'яти рядків і двох стовпців:


```python
a = np.array(range(10), float)
print(a)
a = a.reshape((5, 2))
print(a)
print(a.shape)
```

    [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]
    [[0. 1.]
     [2. 3.]
     [4. 5.]
     [6. 7.]
     [8. 9.]]
    (5, 2)
    

Зверніть увагу, метод reshape створює новий масив, а не модифікує оригінальний.

Майте на увазі, зв'язування імен у python працює і з масивами. Метод copy використовується для створення копії наявного масиву в пам'яті:


```python
a = np.array([1, 2, 3], float)
b = a
c =  a.copy()
a[0] = 0
print(a)
print(b)
print(c)
```

    [0. 2. 3.]
    [0. 2. 3.]
    [1. 2. 3.]
    

Списки можна теж створювати з масивів:


```python
a = np.array([1, 2, 3], float)
print(a.tolist())
print(list(a))
```

    [1.0, 2.0, 3.0]
    [1.0, 2.0, 3.0]
    

Заповнення масиву однаковим значенням.


```python
a = np.array([1, 2, 3], float)
print(a)
print(a.fill(0))
print(a)
```

    [1. 2. 3.]
    None
    [0. 0. 0.]
    

Транспонування масивів також можливе, при цьому створюється новий масив:


```python
a = np.array(range(6), float).reshape((2, 3))
print(a)
print(a.transpose())
```

    [[0. 1. 2.]
     [3. 4. 5.]]
    [[0. 3.]
     [1. 4.]
     [2. 5.]]
    

Багатовимірний масив можна переконвертувати в одновимірний за допомогою методу flatten:


```python
a = np.array([[1, 2, 3], [4, 5, 6]], float)
print(a)
print(a.flatten())
```

    [[1. 2. 3.]
     [4. 5. 6.]]
    [1. 2. 3. 4. 5. 6.]
    

Два або більше масивів можна сконкатенувати за допомогою методу concatenate:


```python
a = np.array([1,2], float)
b = np.array([3,4,5,6], float)
c = np.array([7,8,9], float)
print(np.concatenate((a, b, c)))
```

    [1. 2. 3. 4. 5. 6. 7. 8. 9.]
    

Якщо масив не одновимірний, можна задати вісь, за якою відбуватиметься з'єднання. За замовчуванням (не задаючи значення осі), з'єднання відбуватиметься за першим виміром:


```python
a = np.array([[1, 2], [3, 4]], float)
b = np.array([[5, 6], [7,8]], float)
print(np.concatenate((a,b)))
print(np.concatenate((a,b), axis=0))
print(np.concatenate((a,b), axis=1))
```

    [[1. 2.]
     [3. 4.]
     [5. 6.]
     [7. 8.]]
    [[1. 2.]
     [3. 4.]
     [5. 6.]
     [7. 8.]]
    [[1. 2. 5. 6.]
     [3. 4. 7. 8.]]
    

Насамкінець, розмірність масиву може бути збільшена при використанні константи newaxis у квадратних дужках:


```python
a = np.array([1, 2, 3], float)
print(a)
print(a[:,np.newaxis])
print(a[:,np.newaxis].shape)
print(b[np.newaxis,:])
print(b[np.newaxis,:].shape)
```

    [1. 2. 3.]
    [[1.]
     [2.]
     [3.]]
    (3, 1)
    [[[5. 6.]
      [7. 8.]]]
    (1, 2, 2)
    

Зауважте, тут кожен масив двовимірний; створений за допомогою newaxis має розмірність один. Метод newaxis підходить для зручного створення належно-вимірних масивів у векторній і матричній математиці.

## Інші шляхи створення масивів

Функція arange аналогічна функції range, але повертає масив:


```python
print(np.arange(5, dtype=float))
print(np.arange(1, 6, 2, dtype=int))
```

    [0. 1. 2. 3. 4.]
    [1 3 5]
    

Функції zeros і ones створюють нові масиви зі встановленою розмірністю, заповнені цими значеннями. Це, напевно, найпростіші у використанні функції для створення масивів:


```python
print(np.ones((2,3), dtype=float))
print(np.zeros(7, dtype=int))
```

    [[1. 1. 1.]
     [1. 1. 1.]]
    [0 0 0 0 0 0 0]
    

Функції zeros_like і ones_like можуть перетворити вже створений масив, заповнивши його нулями та одиницями відповідно:


```python
a = np.array([[1, 2, 3], [4, 5, 6]], float)
print(np.zeros_like(a))
print(np.ones_like(a))
```

    [[0. 0. 0.]
     [0. 0. 0.]]
    [[1. 1. 1.]
     [1. 1. 1.]]
    

Також є деяка кількість функцій для створення спеціальних матриць. Для створення квадратної матриці з головною діагоналлю, яка заповнена одиницями, скористаємося методом identity:


```python
print(np.identity(5, dtype=float))
```

    [[1. 0. 0. 0. 0.]
     [0. 1. 0. 0. 0.]
     [0. 0. 1. 0. 0.]
     [0. 0. 0. 1. 0.]
     [0. 0. 0. 0. 1.]]
    

Функція eye повертає матрицю з одиничками на к-атій діагоналі:


```python
print(np.eye(4, k=0, dtype=float))
```

    [[1. 0. 0. 0.]
     [0. 1. 0. 0.]
     [0. 0. 1. 0.]
     [0. 0. 0. 1.]]
    

## Математичні операції над масивами
Коли для масивів ми використовуємо стандартні математичні операції, має дотримуватися принцип: елемент--елемент. Це означає, що масиви мають бути однакового розміру під час додавання, віднімання і тому подібних операцій:


```python
a = np.array([1,2,3], float)
b = np.array([5,2,6], float)
print(a + b)
print(a - b)
print(a * b)
print(b / a)
print(a % b)
print(b**a)
```

    [6. 4. 9.]
    [-4.  0. -3.]
    [ 5.  4. 18.]
    [5. 1. 2.]
    [1. 0. 3.]
    [  5.   4. 216.]
    

Для двовимірних масивів, множення залишається поелементним і не відповідає множенню матриць. Для цього існують спеціальні функції, які ми вивчимо пізніше.


```python
a = np.array([[1,2], [3,4]], float)
b = np.array([[2,0], [1,3]], float)
print(a * b)
```

    [[ 2.  0.]
     [ 3. 12.]]
    

У разі невідповідності в розмірі викидаються помилки:


```python
a = np.array([1,2,3], float)
b = np.array([4,5], float)
print(a + b)
```


    ---------------------------------------------------------------------------

    ValueError                                Traceback (most recent call last)

    <ipython-input-64-02089d693029> in <cell line: 3>()
          1 a = np.array([1,2,3], float)
          2 b = np.array([4,5], float)
    ----> 3 print(a + b)
    

    ValueError: operands could not be broadcast together with shapes (3,) (2,) 


Однак, якщо розмірність масивів не збігається, вони будуть перетворені для виконання математичних операцій. Це часто означає, що менший масив буде використано кілька разів для завершення операцій. Розглянемо такий приклад:


```python
a = np.array([[1, 2], [3, 4], [5, 6]], float)
b = np.array([-1, 3], float)
print(a)
print(b)
print(a + b)
```

    [[1. 2.]
     [3. 4.]
     [5. 6.]]
    [-1.  3.]
    [[0. 5.]
     [2. 7.]
     [4. 9.]]
    

На додачу до стандартних операторів, у numpy включено бібліотеку стандартних математичних функцій, які можуть бути застосовані поелементно до масивів. Власне функції: abs, sign, sqrt, log, log10, exp, sin, cos, tan, arcsin, arccos, arctan, sinh, cosh, tanh, arcsinh, arccosh, arctanh.


```python
a = np.array([1, 4, 9], float)
print(np.sqrt(a))
```

    [1. 2. 3.]
    

Функції floor, ceil і rint повертають нижні, верхні або найближчі (округлене) значення:


```python
a = np.array([1.1, 1.5, 1.9], float)
print(np.floor(a))
print(np.ceil(a))
print(np.rint(a))
```

    [1. 1. 1.]
    [2. 2. 2.]
    [1. 2. 2.]
    

Також у numpy включено дві важливі математичні константи:


```python
print(np.pi)
print(np.e)
```

    3.141592653589793
    2.718281828459045
    

## Перебір елементів масиву

Проводити ітерацію масивів можна аналогічно спискам:


```python
a = np.array([1, 4, 5], int)
for x in a:
  print(x)
```

    1
    4
    5
    

Для багатовимірних масивів ітерація проводитиметься за першою віссю, так, що кожен прохід циклу повертатиме "рядок" масиву:


```python
a = np.array([[1, 2], [3, 4], [5, 6]], float)
for x in a:
  print(x)
```

    [1. 2.]
    [3. 4.]
    [5. 6.]
    

Множинне присвоювання також доступне під час ітерації:


```python
a = np.array([[1, 2], [3, 4], [5, 6]], float)
for (x, y) in a:
  print(x * y)
```

    2.0
    12.0
    30.0
    

## Базові операції над масивами

Для отримання будь-яких властивостей масивів існує багато функцій. Елементи можуть бути підсумовані або перемножені:


```python
a = np.array([2, 4, 3], float)
print(a.sum())
print(a.prod())
```

    9.0
    24.0
    

У цьому прикладі були використані функції масиву. Також можна використовувати власні функції numpy:


```python
print(np.sum(a))
print(np.prod(a))
```

    9.0
    24.0
    

Для більшості випадків можуть використовуватися обидва варіанти.
Деякі функції дають можливість оперувати статистичними даними. Це функції mean (середнє арифметичне), варіація і девіація:


```python
a = np.array([2, 1, 9], float)
print(a.mean())
print(a.var())
print(a.std())
```

    4.0
    12.666666666666666
    3.559026084010437
    

Можна знайти мінімум і максимум у масиві:


```python
a = np.array([2, 1, 9], float)
print(a.min())
print(a.max())
```

    1.0
    9.0
    

Функції argmin і argmax повертають індекс мінімального або максимального елемента:


```python
a = np.array([2, 1, 9], float)
print(a.argmin())
print(a.argmax())
```

    1
    2
    

Для багатовимірних масивів кожна з функцій може прийняти додатковий аргумент axis і залежно від його значення виконувати функції за певною віссю, поміщаючи результати виконання в масив:


```python
a = np.array([[0, 2], [3, -1], [3, 5]], float)
print(a.mean(axis=0))
print(a.mean(axis=1))
print(a.min(axis=1))
print(a.max(axis=0))
```

    [2. 2.]
    [1. 1. 4.]
    [ 0. -1.  3.]
    [3. 5.]
    

Як і списки, масиви можна відсортувати:


```python
a = np.array([6, 2, 5, -1, 0], float)
print(sorted(a))
a.sort()
print(a)
```

    [-1.0, 0.0, 2.0, 5.0, 6.0]
    [-1.  0.  2.  5.  6.]
    

## Векторна та матрична математика

NumPy забезпечує багато функцій для роботи з векторами та матрицями. Функція dot повертає скалярний добуток векторів:



```python
a = np.array([1, 2, 3], float)
b = np.array([0, 1, 1], float)
print(np.dot(a, b))
```

    5.0
    

Функція dot також може множити матриці:


```python
a = np.array([[0, 1], [2, 3]], float)
b = np.array([2, 3], float)
c = np.array([[1, 1], [4, 0]], float)
print(a)
print(np.dot(b, a))
print(np.dot(a, b))
print(np.dot(a, c))
print(np.dot(c, a))
```

    [[0. 1.]
     [2. 3.]]
    [ 6. 11.]
    [ 3. 13.]
    [[ 4.  0.]
     [14.  2.]]
    [[2. 4.]
     [0. 4.]]
    

Також можна отримати скалярний, тензорний і зовнішній добуток матриць і векторів. Зауважимо, що для векторів внутрішній і скалярний добуток збігається.


```python
a = np.array([1, 4, 0], float)
b = np.array([2, 2, 1], float)
print(np.outer(a, b))
print(np.inner(a, b))
```

    [[2. 2. 1.]
     [8. 8. 4.]
     [0. 0. 0.]]
    10.0
    

NumPy також надає набір вбудованих функцій і методів для роботи з лінійною алгеброю. Це все можна знайти в під-модулі linalg. Цими модулями також можна оперувати з виродженими і невиродженими матрицями. Визначник матриці шукається таким чином:


```python
a = np.array([[4, 2, 0], [9, 3, 7], [1, 2, 1]], float)
print(a)
print(np.linalg.det(a))
```

    [[4. 2. 0.]
     [9. 3. 7.]
     [1. 2. 1.]]
    -48.00000000000003
    

Також можна знайти власний вектор і власне значення матриці:


```python
vals, vecs = np.linalg.eig(a)
print(vals)
print(vecs)
```

    [ 8.85591316  1.9391628  -2.79507597]
    [[-0.3663565  -0.54736745  0.25928158]
     [-0.88949768  0.5640176  -0.88091903]
     [-0.27308752  0.61828231  0.39592263]]
    

Невироджена матриця може бути знайдена так:


```python
b = np.linalg.inv(a)
print(b)
print(np.dot(a, b))
```

    [[ 0.22916667  0.04166667 -0.29166667]
     [ 0.04166667 -0.08333333  0.58333333]
     [-0.3125      0.125       0.125     ]]
    [[1.00000000e+00 5.55111512e-17 0.00000000e+00]
     [0.00000000e+00 1.00000000e+00 2.22044605e-16]
     [0.00000000e+00 1.38777878e-17 1.00000000e+00]]
    

# Векторизація
Процес застосування операцій до всього масиву, а не до окремих елементів



```python
a = np.array([1,2,3,4,5,6])

squared = a**2
squared_first_element = a[0]**2
print(squared_first_element)
print(squared)
```

    1
    [ 1  4  9 16 25 36]
    

# Broadcasting
Механізм який дозволяє виконувати операції між масивами різних розмірностей або форм БЕЗ явного копіювання даних.


```python
a = np.array([1,2,3])
b = np.array([[4], [5], [6]])

result = a + b # операція з використанням broadcasting
```


```python
result
```




    array([[5, 6, 7],
           [6, 7, 8],
           [7, 8, 9]])


