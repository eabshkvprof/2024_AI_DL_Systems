# Лекція 6.4. Функціональне програмування

Перша функція приймає параметр "ім'я" та виводе повідомлення з цим параметром.


```python
def say_hello(name):
    print(f"Добрий день, {name}")

say_hello("Андрій")
say_hello("Том")
say_hello("Анна")
```

    Добрий день, Андрій
    Добрий день, Том
    Добрий день, Анна
    

Деякі параметри ми можемо зробити не обов'язковими. Якщо функція має декілька параметрів, то необов'язкові повинні йти позаду


```python
def say_hello(name="Андрій"):
    print(f"Добрий день, {name}")


say_hello()
say_hello("Том")

def print_person(name, age = 18):
    print(f"Ім'я: {name} та вік: {age}")


print_person("Andrii")
print_person("Том", 37)
```

    Добрий день, Андрій
    Добрий день, Том
    Ім'я: Andrii та вік: 18
    Ім'я: Том та вік: 37
    

У прикладах вище при виклику функції значення передаються параметрами функції за позицією. Але також можна передавати значення параметрам за іменем. Для цього при виклику функції вказується ім'я параметра і йому присвоюється значення:


```python
def print_person(name, age):
    print(f"Ім'я: {name} та вік: {age}")


print_person(age = 22, name = "Андрій")
```

    Ім'я: Андрій та вік: 22
    

За допомогою символу зірочки можна визначити параметр, через який можна передавати невизначену кількість значень. Це може бути корисно, коли ми хочемо, щоб функція отримувала кілька значень, але ми точно не знаємо, скільки саме. Наприклад, визначимо функцію підрахунку суми чисел:


```python
def sum(*numbers):
    result = 0
    for n in numbers:
        result += n
    print(f"Сума = {result}")


sum(1, 2, 3, 4, 5)
sum(3, 4, 5, 6)
```

    Сума = 15
    Сума = 18
    

Після оператора return може йти і складний обчислювальний вираз, результат якого буде повертатися з функції. Наприклад, визначимо функцію, яка збільшує число вдвічі:


```python
def double(number):
    return 2 * number

print(double(10))
```

    20
    

Оператор return не тільки повертає значення, а й здійснює вихід із функції. Тому він повинен визначатися після інших інструкцій. Наприклад


```python
def get_message():
    return "Glory to Ukraine!"
    print("End of the function")

print(get_message())
```

    Glory to Ukraine!
    

Глобальний контекст передбачає, що змінна є глобальною, вона визначена поза будь-якою з функцій і доступна будь-якій функції в програмі.


```python
name = "Tom"


def say_hi():
    print("Hello", name)


def say_bye():
    print("Good bye", name)

say_hi()
say_bye()
```

    Hello Tom
    Good bye Tom
    

Є ще один варіант визначення змінної, коли локальна змінна приховує глобальну з тим самим іменем:


```python
name = "Tom"


def say_hi():
    name = "Bob"
    print("Hello", name)


def say_bye():
    print("Good bye", name)


say_hi()
say_bye()
```

    Hello Bob
    Good bye Tom
    

Якщо ж ми хочемо змінити в локальній функції глобальну змінну, а не визначити локальну, то необхідно використовувати ключове слово global:


```python
name = "Tom"


def say_hi():
    global name
    name = "Bob"
    print("Hello", name)


def say_bye():
    print("Good bye", name)


say_hi()
say_bye()
```

    Hello Bob
    Good bye Bob
    

Під час присвоєння значення у вкладеній функції: n = 25 створюватиметься нова змінна n, яка приховає змінну n з навколишньої зовнішньої функції outer. У підсумку ми отримаємо при виведенні два різних числа. Щоб у вкладеній функції вказати, що ідентифікатор у вкладеній функції буде представляти змінну з навколишньої функції, застосовується вираз nonlocal:


```python
def outer():  # зовнішня функція
    n = 5

    def inner():    # вкладена функція
        nonlocal n  # вказуємо, що n - це змінна з навколишньої функції
        n = 25
        print(n)

    inner()
    print(n)


outer()
```

    25
    25
    

Приклад роботи зарезервованого слова yield


```python
def nextSquare():
    i = 1

    # Нескінченний цикл для генерації квадратів
    while True:
        yield i*i #return
        i += 1  # Починається наступне виконання
        # З цього моменту


# Код для тестування вищезгаданої функції
for num in nextSquare():
    if num > 100:
        break
    print(num)
```

    1
    4
    9
    16
    25
    36
    49
    64
    81
    100
    

# Рекурсія
Це спосіб організації циклічного процесу шляхом виклику рекурсивної функції. Рекурсивна функція - це функція, яка містить код виклику самої себе з метою організації циклічного процесу. За допомогою рекурсивних функцій можна з мінімальним обсягом коду розв'язувати деякі задачі, оминувши використання (оголошення) зайвих структур даних. Рекурсію можна розглядати як альтернативу циклам та ітераціям.


```python
'''
У наведеній реалізації n позначає кількість дисків у початковому стеку, source - початковий стержень, auxiliary - запасний стержень і target - кінцевий стержень.
Функція hanoiTowers() викликається рекурсивно: спочатку переміщується n-1 диск з початкового на допоміжний кілочок,
потім переміщується найбільший диск з початкового на кінцевий, а потім ще n-1 диск з допоміжного на кінцевий кілочок.
'''

def hanoiTowers(n, source, auxiliary, target):
    if n == 1:
        print("Move disk 1 from {} to {}".format(source, target))
        return
    hanoiTowers(n - 1, source, target, auxiliary)
    print("Move disk {} from {} to {}".format(n, source, target))
    hanoiTowers(n - 1, auxiliary, source, target)

hanoiTowers(5, 'A', 'B', 'C')
```

    Move disk 1 from A to C
    Move disk 2 from A to B
    Move disk 1 from C to B
    Move disk 3 from A to C
    Move disk 1 from B to A
    Move disk 2 from B to C
    Move disk 1 from A to C
    Move disk 4 from A to B
    Move disk 1 from C to B
    Move disk 2 from C to A
    Move disk 1 from B to A
    Move disk 3 from C to B
    Move disk 1 from A to C
    Move disk 2 from A to B
    Move disk 1 from C to B
    Move disk 5 from A to C
    Move disk 1 from B to A
    Move disk 2 from B to C
    Move disk 1 from A to C
    Move disk 3 from B to A
    Move disk 1 from C to B
    Move disk 2 from C to A
    Move disk 1 from B to A
    Move disk 4 from B to C
    Move disk 1 from A to C
    Move disk 2 from A to B
    Move disk 1 from C to B
    Move disk 3 from A to C
    Move disk 1 from B to A
    Move disk 2 from B to C
    Move disk 1 from A to C
    

Ще один приклад рекурсивної функції - послідовність Фібоначчі. Ця реалізація використовує рекурсію для обчислення n-го члена послідовності Фібоначчі. Функція фібоначчі приймає на вхід ціле число n і повертає n-й член послідовності.

Базовим випадком є коли n дорівнює 0 або 1, в цьому випадку функція повертає n. Для всіх інших значень n, функція рекурсивно викликає сама себе з n-1 і n-2 на вході, і повертає суму двох отриманих значень.

Ось приклад використання функції фібоначчі:


```python
def fibonacci(n):
    # базовий сценарій
    if n == 0 or n == 1:
        return n

    # рекурсивний сценарій
    else:
        return fibonacci(n-1) + fibonacci(n-2)

fibonacci(5)
```




    5



# Анонімні функції

Лямбда-вирази в мові Python являють собою невеликі анонімні функції, які визначаються за допомогою оператора lambda. Формальне визначення лямбда-виразу:
```
lambda [параметри] : інструкція
```


```python
message = lambda: print("hello")

message()
```

    hello
    

Тут лямбда-вираз присвоюється змінній message. Цей лямбда-вираз не має параметрів, нічого не повертає і просто виводить рядок "hello" на консоль. І через змінну message ми можемо викликати цей лямбда-вираз як звичайну функцію. Фактично він аналогічний такій функції:


```python
def message():
    print("hello")

message()
```

    hello
    

Якщо лямбда-вираз має параметри, то вони визначаються після ключового слова lambda. Якщо лямбда-вираз повертає якийсь результат, то він вказується після двокрапки. Наприклад, визначимо лямбда-вираз, який повертає квадрат числа:


```python
square = lambda n: n * n

print(square(4))
print(square(5))
```

    16
    25
    

У цьому випадку лямбда-вираз приймає один параметр - n. Праворуч від двокрапки йде значення, що повертається, - n* n. Цей лямбда-вираз аналогічний до такої функції:


```python
def square2(n):
    return n * n
```

Аналогічним чином можна створювати лямбда-вирази, які приймають кілька параметрів:


```python
sum = lambda a, b: a + b

print(sum(4, 5))
print(sum(5, 6))
```

    9
    11
    

Хоча лямбда-вирази дають змогу дещо скоротити визначення функцій, проте вони обмежені тим, що вони можуть виконувати лише одну інструкцію. Однак вони можуть бути доволі зручними в тих випадках, коли необхідно використовувати функцію для передачі як параметр або повернення до іншої функції. Наприклад, передача лямбда-виразу як параметра:


```python
def do_operation(a, b, operation):
    result = operation(a, b)
    print(f"result = {result}")

do_operation(5, 4, lambda a, b: a + b)
do_operation(5, 4, lambda a, b: a * b)
```

    result = 9
    result = 20
    

У цьому випадку нам немає необхідності визначати функції, щоб передати їх як параметр, як у минулій статті.

Те ж саме стосується і повернення лямбда-виразів із функцій:


```python
def select_operation(choice):
    if choice == 1:
        return lambda a, b: a + b
    elif choice == 2:
        return lambda a, b: a - b
    else:
        return lambda a, b: a * b


operation = select_operation(1)  # operation = sum
print(operation(10, 6))

operation = select_operation(2)  # operation = subtract
print(operation(10, 6))

operation = select_operation(3)  # operation = multiply
print(operation(10, 6))
```

    16
    4
    60
    

# Map (відображення на послідовність)
Вбудована в Python функція map() використовується для застосування функції до кожного елемента ітерованого об'єкта (наприклад, списку або словника) і повернення нового ітератора для отримання результатів. Функція map() повертає об'єкт map (ітератор), який ми можемо використовувати в інших частинах нашої програми. Також ми можемо передати об'єкт map у функцію list() або інший тип послідовності для створення ітерованого об'єкта.
Функція map() має такий синтаксис:
```
map(function, iterable, [iterable 2, iterable 3, ...])
```
Замість використання циклу for функція map() дає можливість застосувати функцію до кожного елемента ітерованого об'єкта. Це підвищує продуктивність, оскільки функція застосовується тільки до одного елемента за раз без створення копій елементів в іншому ітерованому об'єкті. Це особливо корисно при обробці великих наборів даних. Також map() може приймати кілька ітерованих об'єктів як аргументи функції, відправляючи у функцію по одному елементу кожного ітерованого об'єкта за раз.
Наприклад є список:


```python
numbers = [10, 15, 21, 33, 42, 55]
```

Щоб застосувати вираз до кожного з наших чисел, ми можемо використовувати map() і lambda:


```python
mapped_numbers = list(map(lambda x: x * 2 + 3, numbers))
mapped_numbers_2 = map(lambda x: x * 2 + 3, numbers)
```

Тут ми декларуємо елемент у нашому списку як x. Потім ми додамо наш вираз. Ми передамо список чисел як ітерований об'єкт для map().

Для отримання результатів ми роздрукуємо список об'єкта map:


```python
print(mapped_numbers)
```

    [23, 33, 45, 69, 87, 113]
    <map object at 0x78d901bef460>
    

Ми використовували list(), щоб об'єкт map був виведений як список, а не у важкій для інтерпретації об'єктній формі, наприклад: <map object at 0x7fc250003a58>. Об'єкт map є ітератором наших результатів, щоб ми могли використовувати його в циклі for або використовувати list() для перетворення на список. Ми робимо це тут, тому що це хороший спосіб перегляду результатів.

#Анотації функцій
Це функція Python 3, яка дає змогу додавати довільні метадані до аргументів функції та значення, що повертається. Вони були частиною оригінальної специфікації Python 3.0.
Важливо розуміти, що Python не благословляє анотації будь-якою семантикою. Він лише забезпечує синтаксичну підтримку для зв'язування метаданих, а також простий спосіб доступу до неї. Крім того, анотації повністю необов'язкові.

Давайте подивимося на приклад. Ось функція foo(), яка приймає три аргументи, названі a, b і c, і друкує їхню суму. Зверніть увагу: foo() нічого не повертає. Перший аргумент a не анотується. Другий аргумент b анотується рядком 'annotating b', а третій аргумент c анотується з типом int. Значення, що повертається, анотується типом float. Зверніть увагу на синтаксис "->" для анотування значення, що повертається.


```python
def foo(a, b: str, c: int) -> float:
    print(a + b + c)
```

Анотації не впливають на виконання функції. Давайте назвемо foo() двічі: один раз з аргументами int і один раз з рядковими аргументами. В обох випадках foo() робить правильну річ, і анотації просто ігноруються.


```python
foo('Hello', ', ', 'World!')
foo(1, 2, 3)
```

    Hello, World!
    6
    

Також існують аргументи за замовчуванням вказуються після анотації:


```python
def foo(x: 'an argument that defaults to 5' = 5):
    print(x)
foo(7)
foo()
```

    7
    5
    
